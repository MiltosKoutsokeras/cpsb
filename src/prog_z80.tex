\chapter{Sound System}
Making ROMs for the sound system is a little big complicated than for the GFX system. Not only samples and music assets are processed, there is also a need for source code to bootstrap and then run the Z-80. 

\begin{figure}[H]
\sdraw{1.0}{cps1_arch}
\caption*{Three parts, two ROMS}
\end{figure}

The result must be packed into a Z-80 ROM and an OKI ROM. This asymmetry where three system result in two ROM is further complicated by the dependency graph that looks like a plate of spaghetti. 

The crux is that both the sound effects and the music contribute to the OKI ROM content which must be populated in two steps.



\nbdraw{build_graph_sfx}

Luckily, the structure of the OKI ROM faciliated the task since it features an index at the beginning which references all payloads. Leveraging it allows to have a first pass where audio samples are ingested by the build system to generate an incomplete OKI ROM. In a second pass, the music tracks are processed so the new samples are added to the index ROM and the payload appended.

At the very top, \icode{ccps\_sfx} expect artists to provide sound samples contained in \icode{.wav} files which are universally supported. This stage generates a partial OKI ROM and a \icode{.h} header file to be injected in the control build graph so the m68k can request samples playback with a simple ID.

The second stage involves \icode{ccps\_mus}, the music track processor. It expects \icode{.vgm} (Video Game Music) as input since it contains raw 2151 instructions which are easy to convert. It output a finalized OKI ROM containing the sample used by the soundtrack and also a \icode{.c} C file including a custom bytecode containing YM2151 register values, timing, and OKI sample timing.

Finally, the last stage relies on the Small Device C Compiler (SDCC) toolchain. All artifacts generated in the two previous stages are used as input on top of the programmer \icode{.c} files and the bootstrap \icode{crt0.s} assembled by \icode{sdasz80} assembler. All resulting relocatable object files \icode{.rel} are linked together via ssdc's linker \icode{sdldz80}. 


\begin{trivia}
These are a lot of step but if you use \icode{ccps} build system, it is all taken care of with one keystroke resulting in two ROM sets ready to go.
\end{trivia}






\section{Processing Sound Samples}
A wav file is a simple container with a header describing the content followed by a payload. Once the sampling frequency, bit per sample, and number of channel is retrieved, the PCM can be accessed.

Artists should not produce stereo wavs since the CPS-1 is mono. Moreover, game developers should decide if they wish to use the OKI in high quality (7575Hz) or low quality (6060Hz) and all assets should use that sampling rate. Finally, since ADPCM compressed 12-bit sample to 4-bit samples, artists should provide 16-bit PCMs.


\subsection{ADPCM Compression}
% ADPCM is a simple way to compress PCM. In an era where every 1 KiB of ROM was precious, ADPCM was just a vessel allowing 50\% space saving. Upon usage, it is be decompressed by the OKI into PCM to drive a speaker cone.
Decompression is done in hardware by the OKI at runtime but the build system still have to compress assets appropriately. 

% The algorithm to convert PCM to "Dialogic ADPCM" is publicly available and extensively documented by OKI\cite{adpcm_specs}. It is as simple as the decompression algorithm visited in the hardware section on page \pageref{adpcm_decompression_label}.

ADPCM encodes the difference between the previous sample and the sample to be generated. This is done via a 4-bit magnitude nibble. One bit of the magnitude gives the delta sign while the three others encode a delta which value depends on the state of the decoder's \icode{stepSize}.


\lstinputlisting{src/code/adpcm_algo.c}


The starting step index is \icode{0} which translate in the \icode{stepTable} as \icode{16}.

\lstinputlisting[language=C]{src/code/adpcm_compression1.c} 

After each sample compression, the step transition table with the 3-bit value magnitude to see how to update the stepIndex.

\lstinputlisting[language=C]{src/code/adpcm_compression2.c} 

Let's take the example of a stream of 16-bit PCM values received from a wav to be compressed to 4-bit ADPCM values.

\lstinputlisting{src/code/pcm-dpcm.c}

The first 16-bit sample has a value of \icode{960} which becomes \icode{60} in 12-bit. With the current step size at 16, ADPCM can only commands a delta of + ( 16 + 16/2 + 16/4) = +28 which it encodes in a nibble \icode{0b0111}. The step size index is updated via the the transitionTable to now point to 8 (value \icode{34})

The second 16-bit sample also has a value of \icode{960} which becomes \icode{60} in 12-bit. Since the latest sample output was 28, ADPCM must somehow encode a difference of 60-28 = 32. ADPCM commands a delta of + ( 0 + 34/2 + 34/4) = +33 which it encodes in a nibble \icode{0b0011}. 

The decompressor will output 28 (its last value) + 33 = 61. It will slightly overshot the desired value but we can see how the step size has adapted to the delta requested with only two steps. 

Once again the step size index is updated via the transitionTable to 8 (previous value) -1 = 7, which equals 31.

The third 16-bit sample has a value of \icode{950} which becomes \icode{56} in 12-bit. Since the latest sample output was 61, ADPCM encodes a difference of 56-61 = -5. ADPCM commands a delta of - (0 + 0 + 31/4) = -7 which it encodes in a nibble \icode{0b1001}. 

The decompressor will output 61 (its last value) - 5 = 56. The step size index is updated via the transitionTable to 7 (previous value) -1 = 6, which equals 28.

The last 16-bit sample has a value of \icode{160} which becomes \icode{10} in 12-bit. Since the latest sample output was 56, ADPCM encodes a difference of 10-56 = -46. ADPCM commands a delta of - (28 + 28/2 + 0) = -42 which it encodes in a nibble \icode{0b1110}. 

The decompressor will output 56 (its last value) - 42 = 14. The step size index is updated via the transitionTable to 6 (previous value) + 6 = 12, which equals 50.

Ouput vs INput.

If we graph.

DRAWING

\pagebreak


\section{Structure of the OKI ROM}
The structure of the OKI is very simple. It must feature 128 * 6 bytes table at the beginning. Each entry points to a payload in the ROM. The payload of each entry must be ADPCM stream.

For some reason reason offset 0 in the table index is invalid.

\pagebreak

















\section{Processing Musics}
Making music with FM synthesis is an art which this book does not intend to butcher. The best way to go is to ask musician to work with whatever tool they wish (the amazing DefleMask is highly recommended) and export their symphonies using VGM file format.

The VGM (Video Game Music) is a community effort originating from \icode{smspower.org} to create an audio file format able to support many legacy systems (SEGA consoles, MSX, Neo Geo, and PC) as well as Arcade hardware.

The arcade profile is particularly interesting for the CPS-1 since it uses YM2151 for FM Synthesis and SegaPCM for the samples.

If the YM2151 is obviously a perfect fit that will need no processing, the SegaPCM need some adjustments. As a chip used by SEGA in their AM2 (Amusement Machine 2) from 1985 to 1991, it is superior in capabilities to the MSM6295. It relies on 16-bit PCM, up to 32kHZ sampling, has more channels. and a larger address space.

The build system can take care of compressing the PCM via ADPCM and resample from 32KHz to 8080Hz but it is imperative for the musician to use only two channels to play nicely with the CPS-1 where two channels will be used to play sound effects.

Transforming a VGM into something the Z-80 will be able to use.
\pagebreak





\section{Programming the Z-80}
Programming Zilog's CPU into a sound driver involves doing two things right, bootstrapping and behaving according to the memory map. Solving the memory map is the easier. To avoid page turning, the requirement is reproduced here.

\begin{figure}[H]
{
\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x0000} & \texttt{0x7FFF} & 32 KiB & ROM (32 KiB out of 64 KiB)\\
  \texttt{0x8000} & \texttt{0xBFFF} & 16 KiB & Bank-switched view of rest of ROM\\
  \toprule    
  \texttt{0xD000} & \texttt{0xD7FF} & 2 KiB & RAM \\
\toprule    
  \texttt{0xF000} & \texttt{0xF001} & 2 B & YM2151 registers\\
  \texttt{0xF002} & \texttt{0xF002} & 1 B & OKI OKI6295 registers\\
  \texttt{0xF004} & \texttt{0xF004} & 1 B & Bank Switch control (\icode{SOU1})\\
  \texttt{0xF006} & \texttt{0xF006} & 1 B & OKI MSM6295 H / L mode\\
  \toprule    
  \texttt{0xF008} & \texttt{0xF008} & 1 B & Sound commands (latch 1)\\
  \texttt{0xF00A} & \texttt{0xF00A} & 1 B& Sound commands (latch 2)\\
  \toprule    
\end{tabularx}%
}\caption*{Z-80 memory map.}
\end{figure}


Using \icode{sdcc} is helping a lot here since that compiler offers a keyword no other compiler have named \icode{\_\_at}.

\lstinputlisting[language=C]{src/code/z80/memory_map.c}

With the registers covered, only remains placing the \icode{.text} and \icode{.data} at the right location in ROM. This can easily be done thanks to the awesome \icode{sdldz80} linker via a linker script.

\lstinputlisting[]{src/code/z80/main.lk}

As expected, the \icode{\_DATA} is placed at \icode{0xd000}. The \icode{\_CODE} however is placed not at zero but \icode{0x0200} for reason that will follow soon.
Trivia: Linker map is a powerful tool for debugging.

\subsection{Bootstrapping}
A Z-80 starts fetching and executing instructions from \icode{0x0000} so the bootstrap code \icode{crt0.s} is placed there via \icode{.org 0}.

The code immediatly jumps to \icode{0x100} in order to skip the interrupt handler. The Z-80 can work in interrupt modes 0, 1, and 2. Modes 0 and 2 are the most powerful and the most complex since they imply retrieving the id of the peripheral requesting the interrupt by reading a byte on the data bus. This mecanim allows for many devices to get the attention of the Z-80 but in the case of the CPS-1 it is overkill. Because the Z-80 is setup to run in Interrupt Mode 1, it always jump to \icode{0x38} when interrupted.

At \icode{0x100}, the stack pointer \icode{sp} is set to point at the end of \icode{RAM} (the Z-80 stack grows downward), the first interrupt is requested and a mystery \icode{gsinit} function is called.

All the code in \icode{crt0.s} account for a few bytes, that is why the linker script placed \icode{\_CODE} at \icode{0x200}.

Notice how C functions are prefixed with \icode{\_}.

\lstinputlisting[language=z80]{src/code/z80/crt0.s}








\subsection{Z-80 interrupt}
There are no timer in the Z-80 but two can be found in the YM2151. Timer A is a 10-bit counter while Timer B is a XX-bit counter.

The YM2151 counter fires according to the following formula.

FORMULA

When the YM2151 counter reaches zero, it asserts a line connected to the Z-80 INT line which makes the CPU jumps to address \icode{0x38}.

\lstinputlisting[language=C]{src/code/z80/interrupts.c}

In function \icode{schedInterrupt} we write to the YM2151 counter register a value \icode{XXXXX}. Since the music chip is running at 3.58 MHz this result in an interrupt generate 3,580,000 x XXX = 4ms later. Notice \icode{\_\_at} which allows to manually place variables according to the memory map.

\subsection{Initializing variables}
Before we can jump to \icode{main} function, the bootstrap needs to initalize C variables. As we saw earlier, initialized writable variables use RAM address but intiial values are stored in ROM. These must be copied.

\lstinputlisting[language=z80]{src/code/z80/initVar.s}

\lstinputlisting[language=z80]{src/code/z80/copyvar.s}
 

No initialization of BSS

Also explain \icode{s\_} and \icode{l\_}

\subsection{Linker script}

Trick: Always check out the linker .map file to make sure things are were you wanted them.


\subsection{Threads lock-step}
Interrupt is double function. Read latches and keep track of wall-time in the Z-80.
\subsection{Latches Circular buffer}

Tell about variation in Z-80 driver. Final fight uses the same sound id whereas SF2 uses a translation layer.

\subsection{Buffer processing}

\subsection{Sound Effects with MSM6295}
Trivia: Final Fight = No translation but SF2 uses one.

\subsection{Music with YM2151}

\section{How they did it}
If nothing ever transpired about the work done on the Z-80, some of the member of Capcom Sound Team gave interviews to let us peek into how sounds were made.

One of the most outspoken musician is Yoshihiro Sakaguchi who is the author of all Street Fighter II musics.

\img{capcom_sound_team.png}

The Capcom Sound team. L-R: Yoko Shimomura, Yoshihiro Sakaguchi, Manami Matsumae, Masaki Izumiya, Yasuaki Fujita, Mari Yamaguchi, Minae Fujii, Toshio Kajino, Isao Abe.

\begin{q}{Yoshihiro Sakaguchi\cite{yoko_shimomura_interview}  }

Generally speaking, we do the music and sound effects for Capcom’s games. We’ve got a centralized recording system setup on a PC-98, so that even if we’re writing music for different hardware, we can compose without needing to be able to program.
\end{q}

\begin{q}{Yoko Shimomura, Street Fighter 2 music Composer\cite{beep199010}}

I also studied piano in college, but I loved the Famicom, and would often stay up all night playing it. Then the next day my shoulders would be all stiff, and my piano teacher would scold me, and my Mom even said “I don’t remember raising a daughter like this.” (laughs) I decided that when I graduated, I would go work at a place where I could play both music and Famicom all day without complaints!
\end{q}

\begin{q}{Yoko Shimomura, Street Fighter 2 music Composer\cite{beep199010}}
  
I did not know you could write music with a computer until I joined the company. At the entrance exam, I was asked “what sequencer do you use?” and I had to ask back "What? Is that like an electronic controller?".

They had to teach me from the ground up, and after that it was less musical practice than it was technical. The first music data I turned in was thoroughly corrected, and I was feeling really glum.

I was asked to talk about what I knew about FM generation at the entrance exam. I had no idea what it was, so I thought about AM/FM radio and wrote down "it sounds better these days than it used to."
\end{q}


\begin{trivia}
Talk about music playing faster here.
\end{trivia}