\chapter{Programming the CPS-1: Theory}

To program a CPS-1 board mean to produce five sets of ROMs. These are the graphics assets holding the sprites and tilemap contained in the GFX ROM, the 68000 instructions to pilot the control system, Z-80 ROM which contains not only instructions but also YM2151 bytecode to generate the FM music, and finally MSM6295 ROM where are stored the audio samples.

\nbdraw{prog_systems}

Along the way must be decided of communication protocols for each interfaces used by each system to communicate. Namely the GFX RAM where the control system talks with the gfx system and the two 1-byte latches where control send commands to the audio system.


\section{Language}
Historically CPS-1 developers used assembly to program. It is well suited for the kind of low-level operations to perform but most importantly it is second to none when it comes to instructions compactness. As we will see ROM space is not as plentiful as it seems.

Since the objective of this chapter is to explains how things works, it uses C for its greater readability and wider knowledge base across programmer. A little bit of assembly is used, only to bootstrap the CPUs.

If you ever decide to take your CPS-1 program to the next level, you will without a doubt have to go the assembly way. Just not today.

\section{Down to the metal}
In a programming world were developers are more and more removed from the hardware, programming the Z-80 or the M68000 is a joy.

Without libraries, frameworks, dynamic linker, syscalls, virtual memory, and loader, development happens down to the metal.

An innocent three-line C program is enough to get a glimpse of what awaits us.

\lstinputlisting[language=C]{src/code/variablesDeclaration.c}

After compilation and linking, this program will result into a \icode{program.rom} which will be burned into EPROMs which are mapped somewhere in the CPU address space.

\nbdraw{prog_rom_mapping}

Variable \icode{varA} which is uninitialized, readable, and writable. The linker will have assigned the first location in RAM \icode{B}. Any code that reads or write \icode{varA} in our C program will result in instructions addressing \icode{B}. Likewise, reference to \icode{varB} will result in instructions manipulating \icode{B+1}.

Variable  \icode{varC} is initialized, readable, but NOT writable. The linker will have assigned offset \icode{0x0} in \icode{program.rom} and set it to the desired value (\icode{6}. Knowing that ROM mapping start at \icode{A}, any code referring to \icode{varC} result in instructions manipulating \icode{A}. Likewise, variable \icode{varD} is placed in \icode{program.rom} at offset 1, where value \icode{38} is stored. Instructions manipulates address \icode{A+1}.

Finally we come to variable \icode{varE}. Since it is writable, the linker will have used the next available address in RAM and used \icode{B+2}. But how can the linker initialize that location since it can only write to file \icode{program.rom} which is not mapped there? 

The answer is that it cannot. The "copy-down" must be done when the CPU starts, before executing the \icode{main} function of our program is called. 

This bootstrap, called \icode{crt0}, and other subtle mecanims are detailed in the CPU sections.


\section{Interrupts}

All APIs and interfaces of the machine are well defined. The GFX system expects commands via the GFX RAM and the 68000 bus arbitrates read/write operations. On the Audio side, the YM2151 exposes a multiplexed register and so does the MSM6295 both access are arbitrated by the memory map. The on area which is undefined is the interface between the Control and Audio systems.

Try to think of a design yourself. You have two 1 byte latches, a 68000 running at 10MHz which can write in them but not read. On the other end is a Z-80, working at 3.579 MHz which can read the latches but not write them. How do you make these two CPUs talk to each other with 100\% reliability?

There are many ways to solve this problem. Here is how Street Fighter II board solved it. The first issue is that the reader runs slower than the writer which makes it possible to "miss" a command. Inverting the ratio is done via CPU interrupts. The 68000's IPL1 line is directly connected to the VSYNC line of the video system. Likewise, the Z-80 INT line is connected to the timer (CT1) line of the YM2151.

\nbdraw{interrupt_snd}

This way the writer ticks every 16ms while the reader ticks every 4ms. 

\nbdraw{interrupt_ctrl}

This ensures no commands can be dropped but introduces the problem of duplicates. To avoid these, the Z-80 disregards an input if it is the same as the last one.

This introduces an ultimate problem if the 68000 needs to send the same command twice in a row. To work around this, the writer commits on never writing the same byte twice which is done via a no-op byte (0xFF) written after every command.


\begin{trivia}
In the protocol we described, only one latch is used. The second one is completely disregarded. This is exactly the way Street Fighter II board operates	.
\end{trivia}

\subsection{Implementation details}
Leveraging interrupt turns our single threaded CPU into dual threaded system (except one has to restard from the beginning every time). On both side, is a circular buffers where value are staged	.

The interrupt thread consumes the buffer and, depending on which side of the latches they are, either read or write one byte.

\nbdraw{latches_intercafe}

\nbdraw{latches_uml}

\pagebreak


\section{Timers}
The interrupt system we just saw is instrumental to keep track of wall-time (the time perceived by players). 

On the Control side it is useful to sample user input at an appropriate interval and make sure GFX animation are player at the right speed. As we saw before the VSYNC interrupt allows to keep track of things in roughly 16ms interval.

Sound also needs to keep track of wall time in order to feed YM2151 music instructions at the right pace. Here we have more flexibility. Whereas VSYNC frequency is fixed,  the Z-80 reprogram the YM2151 timer after each trigger. For the example we will see there is no need to do that so our timer progresses in 4ms increments.

\section{Randomness}

\section{CCPS, the CPS-1 SDK}
Framework CCPS is the CPS-1 SDK companion of this book. It is free and opensource. You can get it with the following command.

\lstinputlisting[language=Bash]{src/code/clone_ccps.sh}


\chapter{Programming the CPS-1: Practice}


\section{Programming the audio system}
Programming the Z-80 is a rewarding experience that takes a programmer down to the metal. The goal of the exercise if to produce a raw block of 64 KiB of instructions that will be burned into EPROM from which the CPU will start execution at address \icode{0x0200}. To help in this endeavor, the compiler can place R/W variables and the stack in RAM which are mapped at \icode{0xD000} in processor address space. Needless to say there are no memory protection, process, or even thread here.




To speak in concrete terms, let's take the example of a seemingly innocuous C code declaring three global variables.

\section{Z-80 crt0}



Can you guess which address the compiler will use for each of these three variables?

The first easy case is varA which is uninitialized with read and write purposes. The compiler will naturally use address 0xD000. If the variable is read before it is written it will have whatever value the RAM had at this location. 

The second easy case if varB which is a const read-only. It can safely be placed around \icode{0x0200} in ROM since it will only be read.

But what should be done with varB? It can be read but it can also be written to so it should be in RAM (likely \icode{0xD001}) but it is initialized with a value coming from the ROM. An operating system would 

\section{Audio assets for the audio system}

\section{Programming the control system}



\section{68000 crt0}
\pagebreak
\simg{0.53}{x68000_XVI.png}

\section{GFX assets for the gfx system}

\pagebreak
\img{smc-70_ad.jpg}
\img{smc-70_capcom.png}