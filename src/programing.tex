\chapter{Software concepts}

Nothing tells your more about a system than the process of actually building software for it.
% The best way to validate knowledge of a computer hardware is to program it. 

The rest of this book describes a full game production pipeline. The goal is to deepen the understanding of Capcom's platform by not only writing code and generating assets but also learning how to process them in order to generate ROMs.

This chapter describes the high-level architecture. It is intentionally light on details since those are provided in subsequent chapters.

The pipeline we will describe ingests the code (\icode{.s}/\icode{.c}) written by programmers, the samples (\icode{.wav}) and musics (\icode{.mvg}) from the musicians, and the graphics assets (\icode{.png}) produced by the artists. The outputs are four sets of ROMs ready to be burned on EPROMs. 

 \begin{figure}[H]
\sdraw{1.0}{game_pipeline}
\caption*{Game ROMs dependency graph}
\end{figure}

\pagebreak
Some dependencies in the graph make a lot of sense. The z80 source code (\icode{.c} and \icode{.s}) only impacts the z80 ROM. Likewise, the 68000 code (also \icode{.c} and \icode{.s}) ends up in the 68000 ROM.

Other dependencies are more convoluted. The \icode{.wav} sample files for example need to be compressed to ADPCM before being added to the OKI ROM. To be referencable at runtime, each sample is given an integer ID. These IDs must be collected into a \icode{.h} header file. That file must be compiled along with the rest of the 68000 code.

Likewise, the \icode{.png} files are transformed before making their way to the GFX ROM. They also require to generate a \icode{.h} header file, this time containing tileID. Additionally, a \icode{.c} file containing each tile palette is generated in order to be compiled into the 68000 ROM. 

An even more complicated graph emerge from the music \icode{.vmg} files. The music track contains YM2151 commands that must be transformed in bytecode, stored in a \icode{.c} file, and compiled along with the z80 code. To be referenced, a header file containing music ID must also be generated and compiled with the 68000 ROM. Lastly, music are embellished with audio samples which must also be compressed to ADPCM and added to the OKI ROM.

To complicate things even further, each of the four ROM mentioned must use different word size and interleaving across chips containing it.

\section{CCPS: The CPS-1 Build System}
As this book was being written, several tools were authored to validate the understanding of the hardware.

Ultimately these tools were combined into a single build system called \icode{ccps}. The rest of this book occasionally refers to \icode{ccps} but tries to keep the abstraction level high so reader can build their own build system if they desire so. 

Even if only to check what obscure compiler flags must be used, it is freely available, open source, and a few command lines away.

\lstinputlisting[style=BashStyle]{src/code/clone_ccps.sh}


% Along the way must be decided of communication protocols for each interfaces used by each system to communicate. Namely the GFX RAM where the control system talks with the gfx system and the two 1-byte latches where control send commands to the audio system.


\section{Programming Language}
For all their CPS-1 titles, Capcom developers used z80/m68k assembly. They did not have much choice anyway since high-level languages did not allow variable placement and humans were better at hand crafting instructions. Additionally, ROM space was precious and controlling the volume of instructions with accuracy was paramount.

Even with the improvements of compilers capabilities, output compactness and optimization performances, a developer willing to take a CPS-1 to the next level will undoubtedly use assembly.

Since the goal of this book is to explains how things works, it uses C for its greater readability and wider knowledge base among programmers. A little bit of assembly is used but only to bootstrap the CPUs.
	
\section{CPUs Bootstrapping}
Without libraries, frameworks, dynamic linker, syscalls, virtual memory, a loader, or even an operating system, development happens down to the metal. 

Bootstrapping involves simple things like setting the stack pointer and the instruction pointer of a CPU. But it also involves harder tasks like setting up interrupts and more importantly preparing the program to run before calling its \icode{main} function. A innocent six lines C program offers a glimpse into what is involved.

\lstinputlisting[style=CStyle]{src/code/variablesDeclaration.c}

After compilation and linking, this program will result into a binary of raw instructions (no container like ELF or PE) \icode{prog.rom}. Burned on a ROM, is is mapped somewhere in the CPU address space.

During the linking stage, all the variables and functions were given an address in either ROM or RAM. 

\begin{figure}[H]
\nbdraw{prog_rom_mapping}
\caption*{CPU Memory address space, ROM and RAM}
\end{figure}

\subsubsection{Read-only}
The easier symbol to deal with was function \icode{f} which goes in ROM and points to its own instructions.

Another easy symbols are the const \icode{vc} and \icode{vd}. Since they are read only, their values are written to ROM as well. These are grouped in another section \icode{.rodata} apart from functions but nothing fishy there.

\subsubsection{Read-Write}
Symbol \icode{va} is interesting because it is readable but also writable. The linker will have assigned a RAM address. Since it is uninitialized, it point to whatever is there in the RAM when it started.

Symbol \icode{vb} is even more interesting. Like \icode{va} is is readable and writable but unlike \icode{va} it is initialized  to value \icode{0}. The linker can make \icode{va} point to RAM and even group zero-initialized variable together but setting the value to zero cannot be done. This is something the bootstrap will have to somehow take care off.

Finally we come to variable \icode{ve}. Since it is writable, the linker will have used the next available address in RAM after \icode{va}. But how can the linker initialize that location to value \icode{5} since it can only write to file \icode{pro.rom} which is not mapped there? 

The answer is that it cannot. That  task, also called ""copy-down" " is another think the bootstrap will have to take care of.

Since it involves very low operations, both bootstraps (one for z80 and one for m68k) are written using assembly and bundled in a file named \icode{crt0.s}.





\section{Systems communication}

There are many chip in the machine that need to talk to each others. In the hierarchy we studied in the first chapter, each line is an interface. 

\nbdraw{apis}

That is eight communication lines, but the dotted one on the drawing are not programmable which lower the task to five APIs.
% Most of these interfaces are registers where values are written and read. To arbitrate these access, the CPU buses are leveraged.

\subsection{M68000-CPSA, M68000-CPSB} Communication occurs over the CPS-A and CPS-B registers. Additionally draw commands are written by the 68000 to the GFXRAM where they are read by the CPS-A. All accesses to GFXRAM are arbitrated by the 68000 bus protocol.

\subsection{z80-YM2151} Communication occurs over the YM2151 registers which are mapped on the z80 bus. These accesses are arbitrated by the z80 bus protocol.

\subsection{z80-MSM6295} Communication  occurs over the MSM6295 registers which are mapped on the z80 bus. These accesses are arbitrated by the z80 bus protocol. 

\subsection{M68000-z80} Communication between these two CPUs is not trivial. They both have their own bus protocol, run at different speed, have different address space, and data width.

Try to think of a design yourself with the following constraints. There are two 1 byte latches. On one side is a m68k running at 10MHz which can write in them but not read. On the other end is a z80, working at 3.579 MHz which can read the latches but not write them. 

How can you make these two CPUs talk to each other reliably, making sure the stream of commands features no duplicates and no drops?

\subsection{Interrupts}

Both the z80 and the m68k have interrupt systems. These are used to solve many problems and in particular the issue of communicating over the latches.

Since the reader (z80) runs slower than the writer (m68k) it is possible for a latch value to be overwritten (write twice) before it is read. 

Inverting the ratio is done precisely via interrupts. The m68k's IPL1 line is directly connected to the VSYNC line of the video system. Likewise, the z80 INT line is connected to the timer (CT1) line of the YM2151.

\begin{figure}[H]
\nbdraw{interrupt_snd}
\caption*{z80 interrupt system}
\end{figure}

This configuration lets the writer ticks every 16ms while the reader ticks every 4ms. This ensures no latch value can be dropped but introduces the problem of duplicates reads.

To avoid these, the z80 commits to disregards a latch content if its content did not change since the last time it was checked.

\begin{figure}[H]
\nbdraw{interrupt_ctrl}
\caption*{m68k interrupt system}
\end{figure}

This introduces an ultimate problem. It is not possible for the m68k CPU to send the same byte twice in a row. To work around this, the writer commits on never writing the same byte twice which is done via a no-op byte (0xFF) written after every byte.




\subsection{Back then...}
The system and conventions we just described allows to exchange data reliably but it does not give a semantic to the values in the latches. 

A developer is free to give any meaning to the latches since it control both the writer and the reader. Maybe you can even take a second to think how you would design this interface if you had to before we study how Capcom did it.

In a game like Street Fighter II, developers took the approach of not giving values an "immediate" meaning. Communication is a stream of bytes which must be reconstructed on the receiving end before being interpreted.



When interrupted, the z80 read the byte in latch 1 and append it into a circular buffer. Interpretation happen in the non-interrupted thread. A byte value \icode{FE} means that the next byte is the ID of a music that should start playback. 

Otherwise the value is a sound ID to be played immediately on the OKI. This scheme allows for 256 music IDs and 254 samples IDs.

 \begin{figure}[H]
\nbdraw{latches_interface}
\caption*{Street Fighter comm model. Stream encoding via \icode{0xFF}}
\end{figure}

Notice how the encoder, on the m68k side, injects \icode{0xFF} no-op bytes after each write to the latch and how the decoded ignore them.

Note that in this configuration, SF2 only ever uses a single latch while the other is left unused.

\subsubsection{One Sound driver to rule them all}

Given the genericity of the communication system described it would be a fair conclusion to assume all Capcom game used it.

In fact, the "sound driver" kept on evolving, sometimes changing drastically even between two games made consecutively by the same team. 

In Final Fight, a sound ID received for playback is directly forwarded to the OKI whereas, in Street Fighter II, a translation table is used. The ID received is an index into an array where are found the actual OKI ID along with the channel and volume to use.

The merits of a translation table may be explained by the size of Capcom team and the inability to do a "full build" easily at the time.

If the sound team had to change the OKI layout, all IDS used by the m68k would be invalid. With a translation table, the sound team was able to make any change they wanted and keep their ID backward compatible.


\subsection{Another Sound Driver}

The sound driver described in the next pages uses the same architecture as Capcom. It does rely on interrupts on both side. Besides being used for the latch communication, the interrupts also maintain a counter to pace the main threads.

\nbdraw{latches_uml}

The communication protocol however is not streamed. Whereas it is more powerful, it is also much more complicated. For simplicity, a byte is immediately interpreted without need to rebuild a stream.

The byte space is divided in two. If the MSB is set to one \icode{0x80} this is a request for sound effect playback and if the MSB is set to zero \icode{0x00} it indicates a music playback. 

This leaves "only" 126 sound values and 127 music values but it more than enough for the intended purpose. Volume is hard-coded and round-robin rotation is used to pick between channels 1 or 2 to serve a request. 

To play well with channel selection, musicians are requested to use only channels 3 and 4 to embellish their YM2151 melodies. 


\section{Tracking wall-time}
Keeping track of wall-time, the real-time experienced by players, is paramount to both CPUs. 

The m68k must do so in order to sample inputs and run the game engine at the intended speed. The z80 is under the same constrain for the music where it must keep track of pause and notes durations. 

For this purpose the counter maintained by the main thread as used. Only they have different granularity.

The m68k tracks time in units of 16ms while the z80 can do the same in increment of 4ms.


\section{Randomness}
Pseudo-random series of number can be achieved using Maximum-Length LFSRs (Linear Feedback Shift Register) which, on the m68k, give 4,194,304 different values before repeating itself.

The only issue is to pick a seed to initialize the counter. Street Fighter 2 uses the frame counter while other title read the content of the CPU register during bootstrap.

The latter method does not work well when working with emulators and should be avoided.
