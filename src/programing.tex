\chapter{CP-S: Making a Game}

The next three chapters describe a full CPS-1 game production pipeline. 

The goal is to deepen the understanding of Capcom's platform by not only writing code and generating assets but also learning how to process them in order to generate ROMs.

The pipeline inputs consist in the code (\icode{.s}/\icode{.c}) written by programmers and samples (\icode{.wav}), musics (\icode{.mvg}), and graphics assets (\icode{.png}) produced by the artists. The outputs are four sets of ROMs ready to be burned on EPROMs. 

 \begin{figure}[H]
\sdraw{1.0}{game_pipeline}
\caption*{Game ROMs dependency graph}
\end{figure}

Some dependencies in the graph make a lot of sense. The Z-80 source code (\icode{.c} and \icode{.s}) impacts the Z-80 ROM only. Likewise, the 68000 code (also \icode{.c} and \icode{.s}) ends up in the 68000 ROM.

Other dependencies are more convoluted. The \icode{.wav} sample files for example need to be compressed to ADPCM before being added to the OKI ROM. But they must also be referenced in a \icode{.h} header file. A sound identifier integer per sample is used so the 68000 can refer to them when requesting playback.

Likewise, the \icode{.png} files are transformed before making their way to the GFX ROM. They also require to generate a \icode{.h} header file, this time containing tileID. Additionally, a \icode{.c} file containing each tile palette is generated in order to be compiled into the 68000 ROM. 

An even more complicated graph emerge from the music \icode{.mvg} files. The music track contains YM2151 commands that must be transformed in bytecode, stored in a \icode{.c}, and compiled along with the Z-80 code. To be referencable, a header file containing music ID must also be generated and compiled with the 68000 ROM. Lastly, music are embellished with audio samples which must also be compressed to ADPCM and added to the OKI ROM.

To complicate things even further, each of the four ROM mentioned must use different word size and interleaving across chips containing it.

\subsection{CCPS: The CPS-1 Build System}
As this chapter was being written, several tools were authored in particular to establish the correct way to drive the Z-80 and the 68000 compiler. 

Ultimately these tools were combined into a single build system called \icode{ccps}. The rest of this book occasionally refers to \icode{ccps} but try to keep the abstraction level high so reader can build their own build system. 

Even if only to check what obscure compiler flags should be used, it is freely available, open source, and a few command lines away.

\lstinputlisting[language=Bash]{src/code/clone_ccps.sh}


% Along the way must be decided of communication protocols for each interfaces used by each system to communicate. Namely the GFX RAM where the control system talks with the gfx system and the two 1-byte latches where control send commands to the audio system.


\section{Programming Language}
For all their CPS-1 titles, Capcom developers used z80/m68k assembly. They did not have much choice anyway since high-level languages did not allow variable placement and humans were better at hand crafting instructions. Additionally, ROM space was precious and controlling the volume of instructions with accuracy was paramount.

Even with the improvements of compilers capabilities, output compactness and optimization performances, a developer willing to take a CPS-1 to the next level will undoubtedly use assembly.

Since the goal of this book is to explains how things works, it uses C for its greater readability and wider knowledge base among programmer. A little bit of assembly is used but only to bootstrap the CPUs.
	
\section{CPUs bootstrapping}
Without libraries, frameworks, dynamic linker, syscalls, virtual memory, a loader, and even an operatin system, development happens down to the metal. 

Bootstrapping involves simple things like setting the stack pointer and the instruction pointer. But it can involves much more like setting up interrupts and more importantly preparing the program to run before calling its  \icode{main} function. A innocent five liner C program is enough to get a glimpse of what is involved.

\lstinputlisting[language=C]{src/code/variablesDeclaration.c}

After compilation and linking, this program will result into a binary of raw instructions (no container like ELF or PE) \icode{prog.rom}. Burned on a ROM, is is mapped somewhere in the CPU address space.

\nbdraw{prog_rom_mapping}

Variable \icode{varA} which is uninitialized, readable, and writable. The linker will have assigned the first location in RAM \icode{B}. Any code that reads or write \icode{varA} in our C program will result in instructions addressing \icode{B}. Likewise, reference to \icode{varB} will result in instructions manipulating \icode{B+1}.

Variable  \icode{varC} is initialized, readable, but NOT writable. The linker will have assigned offset \icode{0x0} in \icode{program.rom} and set it to the desired value (\icode{6}. Knowing that ROM mapping start at \icode{A}, any code referring to \icode{varC} result in instructions manipulating \icode{A}. Likewise, variable \icode{varD} is placed in \icode{program.rom} at offset 1, where value \icode{38} is stored. Instructions manipulates address \icode{A+1}.

Finally we come to variable \icode{varE}. Since it is writable, the linker will have used the next available address in RAM and used \icode{B+2}. But how can the linker initialize that location since it can only write to file \icode{program.rom} which is not mapped there? 

The answer is that it cannot. The "copy-down" must be done when the CPU starts, before executing the \icode{main} function of our program is called. Also talk about zeroing the BSS.

This bootstrap, called \icode{crt0}, and other subtle mechanisms are detailed in the CPU sections.





\section{Systems communication}

There are many chip in the machine that need to talk to each others. In the hierarchy we studied in the first chapter, each line is an interface. 

\nbdraw{arch_hierarchy}

Most of these interfaces are registers where values are written and read. To arbitrate these access, the CPU buses are leveraged.

The GFX system reads draw commands and the 68000 writes draw commands via the GFX RAM with the 68000 bus arbitrates.

The Z-80 writes commands to the YM2151 and the OKI via registers. Again, these access is arbitrated by the Z-80 bus.

This leave the interface between the Control system and Audio system undefined. Try to think of a design yourself with the following constraints.

There are two 1 byte latches. On one side is a 68000 running at 10MHz which can write in them but not read. On the other end is a Z-80, working at 3.579 MHz which can read the latches but not write them. 

How can you make these two CPUs talk to each other reliably, making sure the stream of commands features no duplicates and no drops?

\subsection{Interrupts}

Both the Z-80 and the 68k have interrupt system. These are used to solve many problems and in particular the issue of communicating over the latches.

Since the reader (z80) runs slower than the writer (68k) it is possible for a latch value to be overwritten (write twice) before it is read. 

Inverting the ratio is done precisely via interrupts. The 68k's IPL1 line is directly connected to the VSYNC line of the video system. Likewise, the Z-80 INT line is connected to the timer (CT1) line of the YM2151.

\begin{figure}[H]
\nbdraw{interrupt_snd}
\caption*{z80 interrupt system}
\end{figure}

This configuration lets the writer ticks every 16ms while the reader ticks every 4ms. This ensures no latch value can be dropped but introduces the problem of duplicates reads.

To avoid these, the Z-80 commits to disregards a latch content if its content did not change since the last time it was checked.

\begin{figure}[H]
\nbdraw{interrupt_ctrl}
\caption*{68k interrupt system}
\end{figure}

This introduces an ultimate problem. It is not possible for the 68k CPU to send the same byte twice in a row. To work around this, the writer commits on never writing the same byte twice which is done via a no-op byte (0xFF) written after every byte.




\subsection{How they did it}
The system and conventions we just described allows to exchange data reliably but it does not give a semantic to the values in the latches. 

A developer is free to give any meaning to the latches since it control both the writer and the reader. Maybe you can even take a second to think how you would design this interface if you had before we study how Capcom did it.

In a game like Street Fighter II, developers took the approach of not giving values an "immediate" meaning. The meaning of a latch depends on the previous value. In this design, the latch are a vector for a stream of byte exchanged between the 68k and the z80.




Only once the stream of bytes is reconstituted on the receiver end, it can be analyzed. A value equals to \icode{FE} means that the next value is the ID of a music that should start playback. Otherwise the value is a sound ID to be played immediately on the OKI. This scheme allows for 256 music IDs and 255 samples IDs (\icode{0FXX} is no hop).

 \begin{figure}[H]
\nbdraw{latches_intercafe}
\caption*{Street Fighter comm model. \icode{0xFF} no-op and ring buffers}
\end{figure}

Note that in this configuration, SF2 only ever uses a single latch while the other is left unused.

Further differences exist, sometimes between two games made consecutively by the same team. In Final Fight, a sound ID received for playback is directly forwarded to the OKI whereas, in Street Fighter II, a translation table is used. The ID received is an index into an array where are found the actual OKI ID along with the channel and volume to use.

The merits of a translation table versus "immediate" values may be explained by the sheer size of Capcom team working on an arcade game. With forty people working on a big game, an API could be decided and need for adjustment never necessary. Audio artist could organize their ROM however they pleased and always properly respond to the initial API agreement.


\subsection{How we will do it}

Since the goal of this book is to teach how to make things work, it does not use a streamed design. Instead the whole meaning of a latch value can be determined instantly without need to inspect the next values.

A single byte value space is divided two. A MSB set to one \icode{0x80} request a sound effect playback and a MSB set to zero \icode{0x00} indicates a music playback. 

This leaves 126 sound values and 127 music values. Volume is hard-coded and round-robin rotation is used to pick between two channels to serve a request. The music track uses the two other channels to embellish YM2151 melodies. 

On the interrupt side, we will use lockestepped main and interrupt thread. The \icode{main} thread only moves forward when an interrupt has run.

\nbdraw{latches_uml}
\pagebreak



\section{Tracking wall-time}

Without timers, the CPUs are unable to keep track of wall-time. That would be an issue to play animation at the right speed but also for feeding the YM2151 at the appropriate page, respecting duration and silences. 

Thankfully the interrupt system can be leveraged to solve this issue as well. By incrementing a counter on each interruption, the 68k can be track in increment of 16ms while the z80 can do the same in increment of 4ms.



% On the Control side it is useful to sample user input at an appropriate interval and make sure GFX animation are player at the right speed. As we saw before the VSYNC interrupt allows to keep track of things in roughly 16ms interval.

% Sound also needs to keep track of wall time in order to feed YM2151 music instructions at the right pace. Here we have more flexibility. Whereas VSYNC frequency is fixed,  the Z-80 reprogram the YM2151 timer after each trigger. For the example we will see there is no need to do that so our timer progresses in 4ms increments.

\section{Randomness}
Generating a series of pseudo-random numbers can be achieved with a Maximum-Length LFSRs (Linear Feedback Shift Register) and a proper seed. The issue is what to use for the seed. We could use a timer keeper and use the first player inputs. But that would open our games to players gaming the system. A better seed source is to use uptime.

