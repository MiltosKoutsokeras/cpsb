\chapter{Programming the CPS-1: Theory}

To program a CPS-1 board mean to produce five sets of ROMs. These are the graphics assets holding the sprites and tilemap contained in the GFX ROM, the 68000 instructions to pilot the control system, Z-80 ROM which contains not only instructions but also YM2151 bytecode to generate the FM music, and finally MSM6295 ROM where are stored the audio samples.

\nbdraw{prog_systems}

Along the way must be decided of communication protocols for each interfaces used by each system to communicate. Namely the GFX RAM where the control system talks with the gfx system and the two 1-byte latches where control send commands to the audio system.


\section{Language}
Historically CPS-1 developers used assembly to program. It is well suited for the kind of low-level operations to perform but most importantly it is second to none when it comes to instructions compactness. As we will see ROM space is not as plentiful as it seems.

Since the objective of this chapter is to explains how things works, it uses C for its greater readability and wider knowledge base across programmer. A little bit of assembly is used, only to bootstrap the CPUs.

If you ever decide to take your CPS-1 program to the next level, you will without a doubt have to go the assembly way. Just not today.

\section{Down to the metal}
In a programming world were developers are more and more removed from the hardware, programming the Z-80 or the M68000 is a joy.

Without libraries, frameworks, dynamic linker, syscalls, virtual memory, and loader, development happens down to the metal.

An innocent three-line C program is enough to get a glimpse of what awaits us.

\lstinputlisting[language=C]{src/code/variablesDeclaration.c}

After compilation and linking, this program will result into a \icode{program.rom} which will be burned into EPROMs which are mapped somewhere in the CPU address space.

\nbdraw{prog_rom_mapping}

Variable \icode{varA} which is uninitialized, readable, and writable. The linker will have assigned the first location in RAM \icode{B}. Any code that reads or write \icode{varA} in our C program will result in instructions addressing \icode{B}. Likewise, reference to \icode{varB} will result in instructions manipulating \icode{B+1}.

Variable  \icode{varC} is initialized, readable, but NOT writable. The linker will have assigned offset \icode{0x0} in \icode{program.rom} and set it to the desired value (\icode{6}. Knowing that ROM mapping start at \icode{A}, any code referring to \icode{varC} result in instructions manipulating \icode{A}. Likewise, variable \icode{varD} is placed in \icode{program.rom} at offset 1, where value \icode{38} is stored. Instructions manipulates address \icode{A+1}.

Finally we come to variable \icode{varE}. Since it is writable, the linker will have used the next available address in RAM and used \icode{B+2}. But how can the linker initialize that location since it can only write to file \icode{program.rom} which is not mapped there? 

The answer is that it cannot. The "copy-down" must be done when the CPU starts, before executing the \icode{main} function of our program is called. 

This bootstrap, called \icode{crt0}, and other subtle mecanims are detailed in the CPU sections.


\section{Interrupts}

All APIs and interfaces of the machine are well defined. The GFX system expects commands via the GFX RAM and the 68000 bus arbitrates read/write operations. On the Audio side, the YM2151 exposes a multiplexed register and so does the MSM6295 both access are arbitrated by the memory map. The on area which is undefined is the interface between the Control and Audio systems.

Try to think of a design yourself. You have two 1 byte latches, a 68000 running at 10MHz which can write in them but not read. On the other end is a Z-80, working at 3.579 MHz which can read the latches but not write them. How do you make these two CPUs talk to each other with 100\% reliability?

There are many ways to solve this problem. Here is how Street Fighter II board solved it. The first issue is that the reader runs slower than the writer which makes it possible to "miss" a command. Inverting the ratio is done via CPU interrupts. The 68000's IPL1 line is directly connected to the VSYNC line of the video system. Likewise, the Z-80 INT line is connected to the timer (CT1) line of the YM2151.

\nbdraw{interrupt_snd}

This way the writer ticks every 16ms while the reader ticks every 4ms. 

\nbdraw{interrupt_ctrl}

This ensures no commands can be dropped but introduces the problem of duplicates. To avoid these, the Z-80 disregards an input if it is the same as the last one.

This introduces an ultimate problem if the 68000 needs to send the same command twice in a row. To work around this, the writer commits on never writing the same byte twice which is done via a no-op byte (0xFF) written after every command.


\begin{trivia}
In the protocol we described, only one latch is used. The second one is completely disregarded. This is exactly the way Street Fighter II board operates	.
\end{trivia}

\subsection{Implementation details}
Leveraging interrupt turns our single threaded CPU into dual threaded system (except one has to restard from the beginning every time). On both side, is a circular buffers where value are staged	.

The interrupt thread consumes the buffer and, depending on which side of the latches they are, either read or write one byte.

\nbdraw{latches_intercafe}

\nbdraw{latches_uml}

\pagebreak


\section{Timers}
The interrupt system we just saw is instrumental to keep track of wall-time (the time perceived by players). 

On the Control side it is useful to sample user input at an appropriate interval and make sure GFX animation are player at the right speed. As we saw before the VSYNC interrupt allows to keep track of things in roughly 16ms interval.

Sound also needs to keep track of wall time in order to feed YM2151 music instructions at the right pace. Here we have more flexibility. Whereas VSYNC frequency is fixed,  the Z-80 reprogram the YM2151 timer after each trigger. For the example we will see there is no need to do that so our timer progresses in 4ms increments.

\section{Randomness}

\section{CCPS, the CPS-1 SDK}
Framework CCPS is the CPS-1 SDK companion of this book. It is free and opensource. You can get it with the following command.

\lstinputlisting[language=Bash]{src/code/clone_ccps.sh}




\chapter{Programming the Z-80}

The goal of the exercise if to produce a block of 64 KiB that will be burned into a ROM. Inside will be placed not only the Z-80 instructions but also the music tracks.

The responsabilities of the Z-80 are to retrieve 68000 commands from the latches and feed the two sound generating chips. For the music it means not only writing YM2151 intructions but also writing MSM6295 instructions for sound effects used on the track. For the sound effects, it only involves writing to the MSM6295 regisers 

\subsection{Z-80 bootstrap (crt0)}

A Z-80 starts in the simplest way by executing instruction at address \icode{0x0000}. Since the ROM will be mapped at \icode{0x0000-0x7FFF} in Z-80 address space there is no offset to factor in when writing the bootstrap. We write a small piece of assembly and request to have it placed at zero (\icode{.org 0x0000}) at features in \icode{crt0.s}.
\pagebreak

\lstinputlisting[language=z80]{src/code/z80/crt0.s}

The first thing we request from the Z-80 is to jump to label \icode{init} which we placed at \icode{0x100}. This is done to leave space for the interrupt handling routine.

\icode{init} is simple. We setup the stack pointer, enable interrupt mode 1 and request the first interrupt. Note that all symbols provided by C functiosn are prefixed with underscore (\icode{\_}) and studied later.

\subsection{Z-80 interrupt}
The Z-80 can work in interrupt modes 0, 1, and 2. Modes 0 and 2 are the most powerful and the most complex since they imply retrieving the id of the peripheral requesting the interrupt by reading a byte on the data bus. This mecanim allows for many devices to get the attention of the Z-80 but in the case of the CPS-1 it is overkill. 

Only one peripheral generates an interrupt (the YM2151 timer). For this case the Z-80 has a perfect interrupt mode 1 where if the \icode{INT} line is asserted, the CPU jumps to address \icode{0x38}. This explains why we have placed our interrupt handler at \icode{.org 0x38}.


\lstinputlisting[language=C]{src/code/z80/interrupts.c}

Function \icode{schedInterrupt} is fairly trivial. We write to the YM2151 counter register a value \icode{XXXXX}. Since the music chip is running at 3.58 MHz this result in an interrupt generate 3,580,000 x XXX = 4ms later.

With this bootstrap, we have effecively implemented the system we envisioned in the "Theory" chapter with two "threads" running concurrently (but not in parallel).

\subsection{Initializing variables}
Before we can jump to \icode{main} function, the bootstrap needs to initalize C variables. As we saw earlier, initialized writable variables use RAM address but intiial values are stored in ROM. These must be copied.

\lstinputlisting[language=z80]{src/code/z80/initVar.s}

\lstinputlisting[language=z80]{src/code/z80/copyvar.s}


No initialization of BSS

Also explain \icode{s\_} and \icode{l\_}

\subsection{Linker script}

The last piece of the memory map puzzle is to write a linker script to have \icode{\_CODE} and \icode{\_DATA} areas in the right location.

\lstinputlisting[]{src/code/z80/main.lk}

Compiling is done via XXXX. See \icode{ccps} in verbose mode to see individual commands issued to \icode{sdcc} compiler and \icode{sdldz80} linker.

Trick: Always check out the linker .map file to make sure things are were you wanted them.

\subsection{Sound Effects with MSM6295}
Bla

\subsection{Music with YM2151}
Bla




\chapter{Programming the 68000}



\section{68000 crt0}

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}


\pagebreak
\simg{0.53}{x68000_XVI.png}

\section{GFX assets for the gfx system}

\pagebreak
\img{smc-70_ad.jpg}
\img{smc-70_capcom.png}