\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its interaction. 

\begin{figure}[H]
\sdraw{1.0}{control_arch}
\caption*{The control system components}
\end{figure}

If the latch toward the Sound system are small registers, we will see that the GFXRAM, the interface to the GFX System is bigger both in breadth (it features 64 registers) and depth (the API is non-trivial).

Luckily, the 68000 is supported by the  GNU Compiler Collection (GCC). It features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

\nbdraw{build_graph_ctrl}


Nothing particularly difficult in the build graph. GCC is responsible for the entire pipeline with \icode{gcc} compiling C files to obj, \icode{as} assembling S files to obj, and \icode{ld} linking it all together. 

At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 The build graph on the next figure shows that the issues of bootrapping is solved like on the Z-80 with a small assembler programmer \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it consults a 64 32-bit integer array called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}

All other slots except one point to a no-nop routine.




\section{Auto-Interrupt}
Alike the Z-80, the 68000 has multiple interrupt modes. In its most complex form, IPL0, IPL1, and IPL2 encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode is called auto-vector. Here there are not interrupt level. The IPL lines encode an interrupt ID directly that is looked up in the "vector table" starting at offset 24.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{26}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt1.s}

The last piece of the interrupt puzzle is to write the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt2.s}






\section{Memory Map}
As a reminded, here is the desired memory mapping.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA players inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

 GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are signed to a memory region by name.

\lstinputlisting[language=C]{src/code/68000/memory_map.c}

\begin{trivia}
Notice how powerful the linker script can be compred to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using container like \icode{elf}. This avoid the need for an extra conversion using \icode{objcopy}.
\end{trivia}

\section{Initializing variables}
The linker script created markers and requeted section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols as if they were in \icode{.ram} (LMA).

With these elements, zeroing the bss and populating .data with inital values is just a few lines of C.

\lstinputlisting[language=C]{src/code/68000/init_vars.c}

\section{Verifying hardware health}
Capcom games bootstrap process go beyond bootstraping the CPUs. They also verify the health of some components at startup. These are screens rarely, if ever, seen by player since it happens only once when the machine is turned on. During normal operations, that would be once a day.

All CPS-1 games display a slightly different set of text. However all of them end up checking the m68k RAM and the GFXRAM. 

These tests were an important since they allowed the cabinet operator to diagnose some of the issues and avoided a costly return to factory of the whole unit.



\vfill
\begin{figure}[H]
\nbimg{boot_sf2.png}
\caption*{Street Fighter 2 boot screen}
\end{figure}


\pagebreak


The technique used is simple but has its limitation. For all byte in each areas of the RAM and GFXRAM, try to write a value, then try to read it back. If they differ, the GFXRAM is faulty and an error message is displayed. No way to checksum the GFXROM or anything on the Sound System side. The latch system is one way and there would be no way for the Z-80 to surface problems anyway.


The set of tests seem to vary, even in two titles made by a same team consecutively. The GFXRAM part of the RAM hosting the Palettes is not tested in Street Fighter 2 despite having been released after Final Fight.

TODO: More research.

\vfill
\begin{figure}[H]
\nbimg{boot_ffight.png}
\caption*{Final Fight boot screen}
\end{figure}


\pagebreak

\section{Ruling them all}
\label{this}
\pageref{this} pages in, peeling layers one after one another and we have finally reached the heart of the game. Function \icode{main} is where developer trigger their game engine to convert inputs into visual ans audio ouputs.

The architecture is much alike the Z-80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened roughly every 16ms. Its job is to read inputs and save them locally, read latch buffer and write them to the latch, and more importantly, flip the GFXRAM descriptor. 

\begin{trivia}
The \icode{frameCounter} variable not only allow to pace the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible, it is also useful too keep track of wall-time to render animation and game logic properly.
\end{trivia}

Most importantly, flip the double GFXRAM buffer.

\subsection{Commanding sound}
By now it will be abondantly clear that requesting a sound or a music playback is only about writing to a latch and forget about it. Special care has to occur if the engine may request multiple sound during a same frame. If this were to happen the value in the latch could be overwritten before the Z-80 picked it up.

The solution is to implement a system of queue where only one value is requested by frame.

\pagebreak

\lstinputlisting[language=C]{src/code/68000/main.c} 


\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcades operator could configure the difficulty of a game via DIP switches. In a game like Street Fighter 2, eight configuration go from the easiest where 1 coin grants 6 credits to the hardest where four coins grant a single credit. Moreover, operator could disable "Continue coins"\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As featured on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value A.I selects bytecode\cite{sf2aiengine} script.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Map Zone }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMAp &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMAp &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMAp &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMAp &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMAc &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMAc &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMAc &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMAd &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
\caption*{Input bit layouts}
\end{figure}

\subsection{Drawing on screen}
Requesting tiles to be drawn consiste in first descring the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to tell them at what offset the data is.

\subsubsection{Double buffering}
When an image is rendered, neither the data in the GFXRAM nor the registers values can be changed. Otherwise it would result in inconsistent images. Changes should only occur during the VBLANKing which is signaled to the 68000 in \icode{VSync} function.

A proper way is to us a double buffer in the GFXRAM where the currenly used data is not touched while the next one is being prepared. On \icode{VSync} the CPS-A and CPS-B registers are written to point them to the next frame data.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the map and always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system define all these values.

Note that all registers are 16-bit wide to accomodate the 68000 writing to them.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ base}  &  \texttt{0x00} & Sprite and Shape descriptors   \\   
\texttt{SCR1 base} &  \texttt{0x02}  & SCROLL1 descriptors   \\         
\texttt{SCR2 base} &  \texttt{0x04}  & SCROLL2 descriptors   \\     
\texttt{SCR3 base}&  \texttt{0x06}   & SCROLL3 descriptors  \\     
\texttt{ROWSCROLL base} &  \texttt{0x08}  & 256 rowscroll values   \\     
\texttt{Palette base} &  \texttt{0x0A}  & Palettes location   \\   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & SCROLL1 Offset X  \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & SCROLL1 Offset Y    \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & SCROLL2 Offset X    \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & SCROLL2 Offset Y    \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & SCROLL3 Offset X    \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & SCROLL3 Offset Y    \\     
\texttt{Star1    X} &  \texttt{0x18}  & STAR1   Offset X    \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & STAR1   Offset Y    \\  
\texttt{Star2    X} &  \texttt{0x1C}  & STAR2   Offset X    \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & STAR2   Offset Y    \\  
\texttt{ROWSCROLL\_OFFSETS} &  \texttt{0x20}  & Offsets into ROWSCROLL base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers}
\end{figure}

The bases tell the CPS-A where it should expected data in GFXRAM. Registers are 16-bit but address must be 24-bit so values are \icode{>> 8}. 

Scroll offsets are exactly that with coordinates origin in the upper left.

Rowscrolling of SRC1 layer is achieved by two registers. Rowscroll base points to an array of 16-bit values. Rowscroll offset is a list of index into that array indicating how much to X scroll.


\paragraph{Video Control} This register enable/disable misc attributes.

\lstinputlisting[language=C]{src/code/68000/videocontrol.c} 


\pagebreak

All CPS-B registers location change based on the version.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and Order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  4 pen values to draw above OBJ  \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers *for Street Fighter 2	(CPS-B 11)}
\end{figure}

\paragraph{Palette control}This register is used to upload palettes pages. A page is a group of 32 palettes belonging to a same layer.

\lstinputlisting[language=C]{src/code/68000/palettecontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A wait until the next VBLANK.

The graphic chip does not use a fixed base + offset to lookup a Palette page. e.g: If \icode{SCR1} palette is not marked for upload, \icode{SCR2} palette is expected immediately after \icode{OBJ} palette.



\paragraph{Layer control} This register allows to enable or disable a layer indivually (with the exception of OBJ which uses another way). It is also used to define the priority of layers \icode{OBJ}, \icode{SCR1}, \icode{SCR2}, and \icode{SC3} individually.

Note that STARs are always in the back and in order STAR1, STAR2.
\pagebreak

\lstinputlisting[language=C]{src/code/68000/layercontrol.c} 

The board studied in this book used CPS-B 11 which does not support STAR1 and STAR2. That feature was not used much besides in Forgotten Words (\icode{CPS-B 01}) and Strider (also \icode{CPS-B 01}).

\begin{trivia}
Starfields were used so little that the bytecode mapper was removed altogether from the CPS-2 systems.
\end{trivia}

Layer control register is also used to define the order in which OBJ, SCR1, SCR2, and SCR3 should be drawn.

\lstinputlisting[language=C]{src/code/68000/layercontrol2.c} 

This bit layout never changes accross CPS-B.

\paragraph{Priority mask}
The layer located first behind the OBJ layer has the super power of being able to be draw on top of OBJ. The tilemap must be marked as such (descibed in "Rendering SCROLLs" section) and the pen values to be treated specially are to be written in the priority mask registers. Four values can be entered in four registers.



\lstinputlisting[language=C]{src/code/68000/maskcontrol.c} 






\subsubsection{Drawing Shapes and Sprites}
To drawing sprites and shapes, descriptors must be written to the GFX RAM. Each entry takes 8 bytes

\lstinputlisting[language=C]{src/code/68000/sprites.c} 

The attribute two bytes have a special layout.

\lstinputlisting[language=C]{src/code/68000/sprites2.c} 

The end of the list is marked with an entry using attribute value \icode{0xFF00}. 

If the attribute bytes indicate set block sizes to zero, a descriptor commands a simple tile to be drawn. The immense majority of draw calls in a Capcom games are single tile commands.

A shape is made of several single tile draw command resulting in arbitrary forms but a sprite must be rectangular. It is a single draw resulting in multiple tiles rendered but but it does not allow to draw more than the maximum limit of tiles.

The CSP-A will read up to 256 entries there and ignore the rest. This is a hardware limitation. There is no enough time in a raster scan to draw all tiles.

Developers do not have to worry about the \icode{STF29} or GFX partitioning. The tileID is relative to group it belongs to.

\subsubsection{Drawing SCROLLs}

Rendering tilemap is much alike rendering OBJs. Descriptors must be written to the GFX RAM. Each entry is two bytes wide.

\lstinputlisting[language=C]{src/code/68000/scrolls.c} 

The attribute byte is a bit field where we find in particular the palette ID, the group ID which references the priority mask, and the usual flippers.

\lstinputlisting[language=C]{src/code/68000/scrolls2.c} 

All SCROLLs have different size and tile size. But they all features 64x64 (4,096) entries. The CPS-A expects no more and no less. 

% These values make the SCROLL1 (8x8 tiles) 512x512 large, SCROLL2 (16x16 tiles) 1024x1024 large, and SCROLL2 (16x16 tiles) 2018x2048 large.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xrrr}
  \toprule    
  \textbf{Scroll name } & \textbf{ Tiles Dimensions } & \textbf{ Tile size }  & \textbf{Dimension }\\  
  \toprule   
    
\texttt{SCROLL1} & \texttt{64x64} & \texttt{8x 8 } &  \texttt{512x 512 }  \\  
\texttt{SCROLL2} & \texttt{64x64} & \texttt{16x16 } &  \texttt{1024x1024 }   \\  
\texttt{SCROLL3} & \texttt{64x64} & \texttt{32x32 } &  \texttt{2018x2048 }   \\  
  \toprule   
\end{tabularx}
\caption*{SCROLLS tile size and dimensions}
\end{figure}

\begin{trivia}
When the CPS-B they were working with supported the trick, Capcom developer rendered a full back screen without using a single scroll or OBJs. They simply enabled the STAR1 layer without requesting any stars. 

This mean that players who looked at these screens actually started a deep dark night sky.
\end{trivia}

\pagebreak
\subsection{Row Scroll}
Row scrolling allows to dictage a per-line offset. Since it works on the SCROLL2 layer, it is made of 1024 16-bit offset. The hardware does not need to read them all, only what is visible is used (plus one tile height above and below) 224 + 16 + 16 = 256.

Since caculating perspective can be costy, there is a mecanism to allow to generate rowscroll values and use an offset.

DRAWING BASE + offset inside.

This is particularly useful in Street Fighter 2. When a character jumps, the srcrolly does as well and the rowscroll values don't have to be changed, only the offset is modified. 

RowScroll[16] = first visible line.
RowScroll[240] = last visible line. 

Offset are unsigned decal toward left. 
\pagebreak

\begin{figure}[H]
\img{color-00016530.png}
 \caption*{Street Fighter 2}%
 \end{figure}%
\pagebreak

\subsection{Back then...}
Next to no information has ever transpired regarding how the CPS-1 control system was programmed. However one machine is widely rumored to have been used. A rumor seemingly confirmed by the nickname of Hiroaki Kondo, a Capcom composer/sound programmer often credited as "X68K". A rumor further reinforced by the components found inside the machine, which closely match the CPS-1.

The X68000 is a machine largely unknown outside of Japan. But in that country it is known as the "god computer". 
Released in 1987 by SHARP, the X68000 was as beautiful and powerful as it was expensive (¥369,000, roughly \$3000 in 1987 dollars, equivalent to around \$6000 in 2012 dollars).

The hardware in these workstations was mind-blowing at the time. A bet that was especially risky considering the machine has next to no software at launch since it used its DOS-like OS named Human68k.

\vfill

 \begin{figure}[H]
\nbimg{68000.png}
\caption*{The SHARP, "God Computer", X68000 }
\end{figure}

\simg{0.53}{x68000_XVI.png}

\pagebreak

\simg{0.53}{x68000_XVI.png}



Besides its gorgeous "Manhattan" case, the machine packed a surprising amount of "fun" horse power since it features a graphic system supporting 128 hardware 16x16 tiles.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{lX}
  \toprule    
  \textbf{Type } & \textbf{ Content } \\  
  \toprule   
    
CPU & Motorola 68000 10 MHz \\  
RAM & 1MiB \\ 
Video  & Up to 65,536 colors, up to 1024×1024 resolution \\
Graphics & 1 sprite plane, 2 bg planes, 4 bitmap planes\\
Sprite engine & 128 tiles total. 32 tiles per line\\
Background engine & 2 in 256x256 \\
VRAM & 1056 KiB - Sprite storage: 256 tiles\\
Sound chip & Oki MSM6258 (1 channel)  \\ 
Music chip & Yamaha YM2151 (8 channels)  \\ 
Storage & Dual 5 1/4 floppy readers  \\ 
  \toprule   
\end{tabularx}
\caption*{X68000 components}
\end{figure}

The similarities with the CPS-1 are troubling. It is almost like writing a software emulation layer would make it a perfect CPS-1 development machine. However if we look into the details, things are different.

For one thing, the sound chip is an OKI MSM6258. Although it works alike the MSM6296 with ADPCM, it features only one channel which severely impacted how rich the sound effects and music could be.

Most importantly, the Sprite system has a weakness. The number of tile displayable was half the capacity of the CPS-1 (128 instead of 256) but that was an issue easily circumvented thanks to techniques such as Sprite doubler by Koichi Yoshida\cite{x68000spritedoubler} relying on raster effect.

The real issue with the sprite system was the small amount of VRAM allowing to store only 256 tiles. A pity compared to the CPS-1 GFXROM allowing thousands. In these conditions, the limitation was how to manage loading time from the floppy discs which access was quite slow and made a game unplayable is used during gameplay.

\pagebreak

These limitation did not deter Capcom from releasing five games for the platform (Ghouls 'n Ghosts, Final Fight, SF2CE, Super Street Fighter II, and Strider). 

The hardware is so powerful that developers were able, for some games, to do "perfect port" which were visually identical to the arcade version. Capcom's Ghouls 'n Ghosts and Street Fighter 2 are considered perfect whereas Final Fight had to lower the number of enemies on screen.

 SHARP keps on improving the series, adding more RAM (up to 4MiB), HDD (up to 80 MiB). Peripheral manufacturers embraced the computer with extensions cards covering absolutely anything one can thing off. 

 SHARP bet was a success. People did write software for their platform. The X68000 series was immensely successful, even if accounting only for games which saw 823 releases between 1988 and 1999.

\nbimg{68000_series.png}

These machine left such an impression on users that, as of 2022, more than thirty years after the last X68000 came out of the factory, functioning one easily fetch \$2,600 on the secondary market.

\img{SharpX68000ad.jpg}

On the left, the commitment to aesthetic expressed itself down to the pages of SHARP catalog. 

SHARP's design and commitment to excellent with its X68000 line of product belongs in the workstation hall of fame next to Steve Jobs' NeXT.