\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its interaction. 

\begin{figure}[H]
\sdraw{1.0}{cps1_arch}
\caption*{The one to rule them all}
\end{figure}

If the latch toward the Sound system are small registers, we will see that the GFXRAM, the interface to the GFX System is bigger both in breadth (it features 64 registers) and depth (the API is non-trivial).

Luckily, the 68000 is supported by the  GNU Compiler Collection (GCC). It features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

\nbdraw{build_graph_ctrl}


Nothing particularly difficult in the build graph. GCC is responsible for the entire pipeline with \icode{gcc} compiling C files to obj, \icode{as} assembling S files to obj, and \icode{ld} linking it all together. 

At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 The build graph on the next figure shows that the issues of bootrapping is solved like on the Z-80 with a small assembler programmer \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it consults a 64 32-bit integer array called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}

All other slots except one point to a no-nop routine.




\section{Auto-Interrupt}
Alike the Z-80, the 68000 has multiple interrupt modes. In its most complex form, IPL0, IPL1, and IPL2 encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode is called auto-vector. Here there are not interrupt level. The IPL lines encode an interrupt ID directly that is looked up in the "vector table" starting at offset 24.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{26}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt1.s}

The last piece of the interrupt puzzle is to write the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt2.s}






\section{Memory Map}
As a reminded, here is the desired memory mapping.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA players inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

 GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are signed to a memory region by name.

\lstinputlisting[language=C]{src/code/68000/memory_map.c}

\begin{trivia}
Notice how powerful the linker script can be compred to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using container like \icode{elf}. This avoid the need for an extra conversion using \icode{objcopy}.
\end{trivia}

\section{Initializing variables}
The linker script created markers and requeted section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols as if they were in \icode{.ram} (LMA).

With these elements, zeroing the bss and populating .data with inital values is just a few lines of C.

\lstinputlisting[language=C]{src/code/68000/init_vars.c}



\section{Ruling them all}
\section{GFX assets for the gfx system}
\section{Double buffering}
\section{Color brightness}
\section{Drawing shapes}
\section{Drawing sprites}
\section{Drawing SCR1}
\section{Drawing SCR2}
\section{Drawing SCR3}
\section{Drawing STAR1}
\section{Drawing STAR2}

\section{Back then...}
Very little has transpired.
\pagebreak

dsa

\simg{0.53}{x68000_XVI.png}
\pagebreak

Talk about perfect ports.

\img{SharpX68000ad.jpg}

\section{Easter eggs}
720 block
Red Fireball