\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its interaction. 

\begin{figure}[H]
\sdraw{1.0}{control_arch}
\caption*{The control system components}
\end{figure}

While the latch toward the Sound system is a small API surface, the GFX API is huge. The interface to the Graphic System is bigger both in breadth (it features 64 registers) and depth (the expected GFXRAM data layout is non-trivial).

Luckily, the 68000 is supported by the  GNU Compiler Collection (GCC). It features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

Nothing is particularly difficult to understand in this build graph. GCC suite is responsible for the entire pipeline with \icode{gcc} compiling C files to obj, \icode{as} assembling S files to obj, and \icode{ld} linking it all together. 


\nbdraw{build_graph_ctrl}



At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 Alike for the z80, bootrapping is solved with a small assembler program named \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it consults a 64 32-bit integer array called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}

All other slots except for one (offset \icode{26}) point to a no-nop routine.




\section{Auto-Interrupt}
The 68000 has multiple interrupt modes. In its most complex form, IPL0, IPL1, and IPL2 encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode, auto-vector, makes the CPU jump directly based on the three IPL lines state. Three lines gives a value [0,7] which is used to looked up the "vector table" starting at offset 24.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{24 + 2 = 26}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt1.s}

The last piece is the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt2.s}






\section{Memory Map}
Alike for the Sound System and its z80 memory space, we need to make sure the software prehave accordingly to the memory map defined by the board PALs.

The compiler in the GNU Compiler Collection, \icode{gcc} does not have a placemeny keyboard \icode{\_at} but even if it had been available, it would not have been enough to map large portion such as the 196 KiB of GFXRAM.

For what \icode{gcc} lacks, we can compensate thanks to the power of \icode{ld}'s linker script system. The idea is to use a two step method where:
\begin{itemize}
\item First, Define memory regions thanks to the \icode{MEMORY} keyboard.
\item Second Create segments where code and data are stored based on access properties.
\item Third, Connect regions and segments.
\end{itemize}


% As a reminded, here is the desired memory mapping.
\pagebreak

\subsection{Goal}
To avoid flipping pages, here is the memory map studied on page XXX.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA players inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

\subsection{Memory Regions}
 % GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\begin{trivia}
Notice how powerful the linker script is compared to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using container like \icode{elf}. This avoid the extra conversion step from elf to binary using \icode{objcopy}.
\end{trivia}


\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are assigned to a memory region by name.

\begin{trivia}
Notice the care taken to make sure the 68000 will only attempt to access aligned data via \icode{.ALIGN(4)} directives. Unaligned memory access is an unrecoverable error resulting in the 68000 \icode{HALT}ing.
\end{trivia}


\subsection{Code to segment}

\lstinputlisting[style=CStyle]{src/code/68000/memory_map.c}



\section{Initializing variables}
The linker script created markers and requested section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols as if they were in \icode{.ram} (LMA).

With these elements, zeroing the bss and populating .data with initial values is just a few lines of C.

\lstinputlisting[style=CStyle]{src/code/68000/init_vars.c}

\pagebreak
\section{Verifying RAM}
Capcom games bootstrap does more than bringing up the CPUs. They also verify the health of hardware components. These screens are rarely, if ever, seen by players since they are visible only once when the cabinet is turned on. During normal operations, that would be once a day.

All CPS-1 games display a slightly different set of text. However all of them end up checking the m68k RAM and the GFXRAM. 

Faulty RAM could create issues further down the pipeline. A cabinet would then expose faults that could be mis-attributed to other components. By allowing to quickly rules out a whole class of errors, the startup tests sped up debugging and repairing boards.

The technique used is simple but has its limitation. For all byte in each areas of the RAM and GFXRAM, try to write a value, then try to read it back. If they differ, the GFXRAM is faulty and an error message is displayed. 

\begin{trivia}
No way to checksum the GFXROM or the Sound System. The GFXROM is not mapped and the latch system is one way, making it impossible for the Z-80 to surface problems.
\end{trivia}

\vfill
\begin{figure}[H]
\nbimg{boot_ghouls.png}
\caption*{Ghouls 'n Ghosts boot screen}
\end{figure}


\begin{figure}[H]
\nbimg{boot_sf2.png}
\caption*{Street Fighter 2 boot screen}
\end{figure}








% These tests look that something that would be standard and common to every games. Surprisingly they are all different and even differ between two titles made by a same team consecutively. The GFXRAM part of the RAM hosting the Palettes is not tested in Street Fighter 2 despite having been released after Final Fight.



\begin{figure}[H]
\nbimg{boot_forgottn.png}
\caption*{Forgotten Worlds boot screen}
\end{figure}



\vfill
\begin{figure}[H]
\nbimg{boot_ffight.png}
\caption*{Final Fight boot screen}
\end{figure}






\section{Ruling them all}
\label{this}
This is now \pageref{this} page in the "Book of CP-System". With each chapter peeling away a layer of complexity, we have finally reached the heart of the game. 

The function \icode{main} is where developers will have their game engine convert player inputs into visual and audio outputs.

The architecture is much alike the Z-80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened roughly every 16ms. Its job is to read inputs and save them locally, read latch buffer and write them to the latch, and more importantly, flip the GFXRAM double buffered descriptors. 

\begin{trivia}
The \icode{frameCounter} variable not only allow to pace the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible, it is also useful too keep track of wall-time to render animation and game logic properly.
\end{trivia}


\subsection{Commanding sound}
By now it will be abundantly clear that requesting a sound or a music playback is only about writing to a latch and forget about it. 

Special care has to occur if the engine may request multiple sound during a same frame. If this were to happen the value in the latch could be overwritten before the Z-80 picked it up.

The solution is to implement a system of queue where only one value is requested by frame.

However for the simplification and brevity requirement of this book, no queue is used in the following code.

\lstinputlisting[style=CStyle]{src/code/68000/vsync.c} 

\subsection{Main}
\lstinputlisting[style=CStyle]{src/code/68000/main.c} 

How \icode{hostframe} is implemented is completely at the programmer's discretion. Capcom games used a common kernel framework made of tasks. Since there is no source of interrupt beside \icode{vsync} they implemented a collaborative multi-tasking system where the stack and registers are stored/loaded as each task is executed.

In a game like Street Fighter II, the kernek can be found running an A.I task or even a fireball task\cite{sf2platinium}.

\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcades operator could configure the difficulty of a game via DIP switches. In a game like Street Fighter 2, eight configuration go from the easiest where 1 coin grants 6 credits to the hardest where four coins grant a single credit. There is even a "Free Play" mode which no amount of begging could convince operators to enable\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As featured on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value A.I selects "better" bytecode\cite{sf2aiengine} script. The A.I still cheat in all of them by skipping "charging"\cite{sf2aiengine}.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 % \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Map Zone }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMAp &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMAp &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMAp &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMAp &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMAc &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMAc &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMAc &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMAd &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
% \caption*{Input bit layouts}
% \end{figure}  

\subsection{Drawing on screen}
Requesting tiles to be drawn consist in first describing the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to tell them at what offset the data is.

\subsubsection{Double buffering}
When a frame is rasterized, neither the data in the GFXRAM nor the registers values can be changed. Otherwise it would result in inconsistent images. Changes should only occur during the VBLANKing which is signaled to the 68000 via the \icode{VSync} function.

The proper way to avoid visual artifacts is to use a double buffer in the GFXRAM where the currently used data is not written until the next VSYNC. Meanwhile the next frame is being prepared in the other buffer. 

On \icode{VSync} the CPS-A and CPS-B registers are written to point them to the next frame data.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the map and always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system define all these values.

Note that all registers are 16-bit wide to accommodate the 68000 writing to them. As shown in the summary table, a register offset is always located on an even address.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ base}  &  \texttt{0x00} & Sprite and Shape descriptors   \\   
\texttt{SCR1 base} &  \texttt{0x02}  & SCROLL1 descriptors   \\         
\texttt{SCR2 base} &  \texttt{0x04}  & SCROLL2 descriptors   \\     
\texttt{SCR3 base}&  \texttt{0x06}   & SCROLL3 descriptors  \\     
\texttt{ROWSCROLL base} &  \texttt{0x08}  & 256 rowscroll values   \\     
\texttt{Palette base} &  \texttt{0x0A}  & Palettes location   \\   
  \toprule   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & SCROLL1 Offset X  \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & SCROLL1 Offset Y    \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & SCROLL2 Offset X    \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & SCROLL2 Offset Y    \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & SCROLL3 Offset X    \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & SCROLL3 Offset Y    \\     
  \toprule   
\texttt{Star1    X} &  \texttt{0x18}  & STAR1   Offset X    \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & STAR1   Offset Y    \\  
\texttt{Star2    X} &  \texttt{0x1C}  & STAR2   Offset X    \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & STAR2   Offset Y    \\  
  \toprule   
\texttt{ROWSCROLL\_OFFSETS} &  \texttt{0x20}  & Offsets into ROWSCROLL base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers}
\end{figure}

The bases tell the CPS-A where it should expected data in GFXRAM. Registers are 16-bit but address must be 24-bit so values are \icode{<< 8}. 

Scroll offsets are exactly that with coordinates origin in the upper left.

Rowscrolling of SRC1 layer is achieved by two registers. Rowscroll base points to an array of 16-bit values. Rowscroll offset is an offset inside the base. This is elaborated on in the rowscroll section.


\paragraph{Video Control} This register enable/disable misc attributes.

\lstinputlisting[style=CStyle]{src/code/68000/videocontrol.c} 



All CPS-B registers location change based on the version.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and Order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  4 pen values to draw above OBJ  \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers *for Street Fighter 2	(CPS-B 11)}
\end{figure}

\paragraph{Palette control}This register is used to upload palettes pages. A page is a group of 32 palettes belonging to a same layer.

\lstinputlisting[style=CStyle]{src/code/68000/palettecontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A wait until the next VBLANK.

The graphic chip does not use a fixed base + offset to lookup a Palette page. e.g: If \icode{SCR1} palette is not marked for upload, \icode{SCR2} palette is expected immediately after \icode{OBJ} palette.



\paragraph{Layer control} This register allows to enable or disable a layer individually (with the exception of OBJ which uses another way). It is also used to define the priority of layers \icode{OBJ}, \icode{SCR1}, \icode{SCR2}, and \icode{SC3} individually.

Note that STARs are always in the back and in order STAR1, STAR2.
  
\lstinputlisting[style=CStyle]{src/code/68000/layercontrol.c} 

The board studied in this book used CPS-B 11 which does not support STAR1 and STAR2. That feature was not used much besides in Forgotten Words (\icode{CPS-B 01}) and Strider (also \icode{CPS-B 01}).

\begin{trivia}
Starfields were used so little that the bytecode mapper was removed altogether from the CPS-2 while the ASICs retains the circuits.
\end{trivia}

Layer control register is also used to define the order in which OBJ, SCR1, SCR2, and SCR3 should be drawn.

\lstinputlisting[style=CStyle]{src/code/68000/layercontrol2.c} 

This bit layout never changes accross CPS-B.

\paragraph{Priority mask}
The layer located first behind the OBJ layer has the super power of being able to be draw on top of OBJ. The tilemap must be marked as such (described in "Rendering SCROLLs" section) and the pen values to be treated specially are to be written in the priority mask registers. Four values can be entered in four registers.



\lstinputlisting[style=CStyle]{src/code/68000/maskcontrol.c} 






\subsubsection{Drawing Shapes and Sprites}
To drawing sprites and shapes, descriptors must be written to the GFX RAM. Each entry takes 8 bytes

\lstinputlisting[style=CStyle]{src/code/68000/sprites.c} 

The attribute two bytes have a special layout.

\lstinputlisting[style=CStyle]{src/code/68000/sprites2.c} 

The end of the list is marked with an entry using attribute value \icode{0xFF00}. 

If the attribute bytes indicate set block sizes to zero, a descriptor commands a simple tile to be drawn. The immense majority of draw calls in a Capcom games are single tile commands.

A shape is made of several single tile draw command resulting in arbitrary forms but a sprite must be rectangular. It is a single draw resulting in multiple tiles rendered but but it does not allow to draw more than the maximum limit of tiles.

The CSP-A will read up to 256 entries there and ignore the rest. This is a hardware limitation. There is no enough time in a raster scan to draw all tiles.

Developers do not have to worry about the \icode{STF29} or GFX partitioning. The tileID is relative to group it belongs to.

\subsubsection{Drawing SCROLLs}

Rendering tilemap is much alike rendering OBJs. Descriptors must be written to the GFX RAM. Each entry is two bytes wide.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls.c} 

The attribute byte is a bit field where we find in particular the palette ID, the group ID which references the priority mask, and the usual flippers.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls2.c} 

All SCROLLs have different size and tile size. But they all features 64x64 (4,096) entries. The CPS-A expects no more and no less. 
 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xrrr}
  \toprule    
  \textbf{Scroll name } & \textbf{ Tiles Dimensions } & \textbf{ Tile size }  & \textbf{Dimension }\\  
  \toprule   
    
\texttt{SCROLL1} & \texttt{64x64} & \texttt{8x 8 } &  \texttt{512x 512 }  \\  
\texttt{SCROLL2} & \texttt{64x64} & \texttt{16x16 } &  \texttt{1024x1024 }   \\  
\texttt{SCROLL3} & \texttt{64x64} & \texttt{32x32 } &  \texttt{2018x2048 }   \\  
  \toprule   
\end{tabularx}
\vspace*{-1mm} % Ugly hack to make release typeset be like debug. No idea why there is a difference.
\caption*{SCROLLS tile size and dimensions}
\end{figure}

% \begin{trivia}
As alluded in the hardware chapter,a  full back screen can be rendered without using a single scroll or OBJs.

Enabling the STAR1 layer without requesting any stars via the bytecode does the trick. It only works if the CPS-B on the board support STARfield (few do). Street Fighter II Champion Edition, a game using no STARfield, features a STARfield capable CPS-B vXX which is used in the popup logo scene.
% \end{trivia}



\subsubsection{Row Scroll}
Rowscrolling allows to offset each visible row via a discrete X amounts. In Street Fighter II, Honda's dohyō ( the space in which a sumo wrestling bout occurs) perspective is achieved via linear offset differences. The more perspective needed, the more accentuated is the offset slope. 

\begin{figure}[H]
\nbimg{ring_skew_none.png}
\caption*{Fighters at the center of the dohyō.}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_left.png}
\caption*{Fighters move to the left of the dohyō.}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_right.png}
\caption*{Fighters move to the right of the dohyō.}
 \end{figure}%

To sroll each row, the CPS-A reads 256 values. That is 224 (each visible lines) + 16 (one tile height above) + 16 (one tile heigh below) = 256 values to render a frame.

Each unsigned 16-bit offset value is expected in an array located in GFXRAM and pointed to via the CPS-A register \icode{ROWSCROLL\_BASE}.

The \icode{ROWSCROLL\_OFFSET} instructs the CPS-A to use values not starting at \icode{ROWSCROLL\_BASE} but at \icode{ROWSCROLL\_BASE} + \icode{ROWSCROLL\_OFFSET}. 

\begin{figure}[H]
\nbdraw{rowscroll}
 \caption*{CPS-A rowscroll data access}%
 \end{figure}%

A convenient trick is to allocate a rowscroll array of size 1024 (one entry for the full height of SCROLL2), generate all the rowscrollo offset and only manipulate \icode{ROWSCROLL\_OFFSET} if SCROLL2 is moved vertically. When a contestant in Street Figther II jumps, SCROLL2 moves vertically but no rowscroll offset are re-calculated, only \icode{ROWSCROLL\_OFFSET}  is moved. This allows to amortize the generation of perspective correct rowscroll offset.

\lstinputlisting[style=CStyle]{src/code/68000/rowscroll.c} 


Note that rowscroll offsets are unsigned and always indicate an amount to move toward the left side of the screen. To offset toward the right, a developer can take advantage of the wrap around nature of the SCROLL layers and use \icode{decalValue = 1024 - desiredRightOffsetValue}.

% \begin{trivia}
% Honda's SCROLL2 features hidden message. It looks like the designers left construction block writings as Upper left, (\begin{CJK}{UTF8}{min}左上\end{CJK}), Upper middle (\begin{CJK}{UTF8}{min}中上\end{CJK}), and Upper right (\begin{CJK}{UTF8}{min}右上\end{CJK}) kanji can be spotted.
% \end{trivia}


















\pagebreak

\subsection{Back then...}
The system used by Capcom to program the CP-System remained unknown for many years. Only the nickname of Hiroaki Kondo, a composer/sound programmer often credited as "X68K", rumored a computer manufactured by Sharp. 

In 2018,  Akiman confirmed\cite{x68000usage1}\cite{x68000usage2} that Capcom's SDK, named CAT-1, was launched during the making of Street Fighter II and ran on a Sharp X68000.

\subsubsection{SHARP X68000}

Unheard of in the rest of the world, the X68000 is a celebrity in Japan where it is called "god computer". 
Released in 1987, the first machine in the series was as beautiful and powerful as it was expensive (¥369,000, roughly \$3000 in 1987, equivalent to \$7,600 in 2022).

\vfill

 \begin{figure}[H]
\nbimg{68000.png}
\caption*{The SHARP, "God Computer", X68000 }
\end{figure}


Despite mind-blowing hardware specifications, SHARP's new product was a risky bet considering it had next to no software at launch. To complicate things further, it used its own text-based OS named Human68k.


\begin{wrapfigure}[37]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_front.png}
\end{wrapfigure}

The "Manhatthan" twin-tower case of the first model became the signature of the series. 

Notice the vertical bar between the two towers. Pushing it down release a spring to allow the bar to extends past the top of the machine and become a carrying handle.


The most convenient ports for the keyboard, mouse, and joystick are conveniently user facing. An audio jack and a volume control are also present.

The two 5.25 floppy have elegant motorized "soft" ejection systems.

The three leds in the upper right indicates the state of the machine. If \icode{POWER} is self-explanatory, \icode{HIGH RESO} indicates whether the video output is using 15KHz, 24KHz, or 31kHz whereas \icode{TIMER} indicates if a self-powering is scheduled. 

In later revisions, \icode{HIGH RESO} was replaced with \icode{HD BUSY} to indicate HDD state.

Oh my God. It even has a front facing orange power button.

On the back panel can be found "standard" ports such as additional \icode{Line In} and \icode{Line Out}, and an extra \icode{Joystick \#2} entry.  packed with ports and extension points, illustrates the power of the workstation.

\pagebreak

\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_back.png}
\end{wrapfigure}



The \icode{TV Control} port allows to drive Sharp monitors and VCRs. It can take advantage of the timer mentioned earlier to schedule a tape recording.

The \icode{See through Color} port is for chroma-keying and rotoscoping.

A \icode{Image In} port for transferring images from a video device, such as a VCR.

A serial port, \icode{RS232C}, as found on many IBM PCs.



The \icode{HDD} and \icode{FDD} ports respectively allow Hard-Drive and Floppy-Drive extensions.

The \icode{100V out} outlet provides power for a monitor.

The \icode{Analog RGB out} port is the equivalent a VGA port to carry the monitor signal.


The \icode{Stereoscopic} port drives “shutter style” 3D glasses.

The \icode{Printer} port is a variant of the commonly called parallel port in USA only it is called Mini-Centronics 36-pin. 

For everything else, the X68000 features two \icode{extension slots} to welcome extension cards.

\textbf{Trivia:} The two \icode{FG} screws are meant for Frame Grounding since Japanese power outlets lack Ground wire and therefore a not grounded.


\pagebreak



\subsubsection{Tech specs}  
Inside its gorgeous "Manhattan" case, the machine packed an unparalleled amount of horse power. Even a machine such as the Amiga 500, released the same year and praised in Europe and USA for its prowess, pales in comparison to the X68000. 


 \begin{figure}[H]
\begin{tabularx}{\textwidth}{lXX}
  \toprule    
  \textbf{Type } & \textbf{ X68000 } & \textbf{ Amiga 500 }\\  
  \toprule   
    
CPU & M68000 10MHz & M68000 7.16 MHz\\  
RAM & 1MiB & 512 KiB\\
Max RAM & 4 MiB & 2 MiB\\ 
Colors  & 65,536 colors (stable) & 4,096 (HAM) \\
Resolution & 1024×1024 & 736x483 \\
% Graphics & 1 sprite plane, 2 bg planes, 4 bitmap planes& \\
Sprite engine & 128 units, 16x16 tiles & 8 units, 16x16 tiles\\
% Background engine & 2 in 256x256 \\
VRAM & 1056 KiB & -\\
Sound & Oki MSM6258 (1 channel)  & 4 channels PCM\\ 
Music & Yamaha YM2151 (8 channels)  & -\\ 
Price & \$5,000 & \$1,500 \\
% Storage & Dual 5.25 floppy readers  & \\ 
  \toprule   
\end{tabularx}
\caption*{X68000 vs Amiga 500}
\end{figure}


If both music and sound capabilities were outstanding, it is in the graphics department that the X68000 made jaws hit the floor.

The 1056 KiB of VRAM are divided into three segments feeding four planes. 512 KiB are dedicated to the Text plane, 512 KiB are for the Bitmap plane and the rest, 32 KiB, are for the joined use of the Background plane and Sprite plane. Each plane can be configured to host various resolution and layers.

\subsubsection{Video prowess}

The \textbf{Bitmap Plane} is particularly well suited to plot pixels and render images. Its direct 16bpp color mode was ideal for raytracing application (a M68881 math coprocessor could be added to reduce rendering time). 


\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 512x512 layer with direct 16bpp colors.
\item Two 512x512 layers with 8bpp indexed colors.
\item Four 512x512 layers with 4bpp indexed colors.
\item One 1024x1024 layer in 4bpp indexed colors.
\end{itemize}

The \textbf{Text Plane} is deceivingly named. It is a bitmap plane which unlike the bitmap plane, expects value accross bitplanes making it well suited to set a large quantity of bits with a single write. A 68000 writing a 16-bit word can set 16 pixels which makes text rendering very fast when copying characters from a model. 

\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 1024x1024 layer with 4bpp indexed colors.
\item Four 512x512 layers with 1bpp monochrome.
\end{itemize}


The \textbf{Background Plane} works as a tilemap. 
\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item Two 512x512 tilemaps using 8x8 tile with 4bpp indexed colors.
\item One 1024x1024 tilemap using 16x16 tiles with 4bpp indexed colors.
\end{itemize}

Finally, the \textbf{Sprite Plane} is a sprite layer allowing 128 sprite on-screen (with a max of 32 sprites per scanlines).


 \begin{figure}[H]
\nbdraw{z68k_layers}
\caption*{X68000 planes and layers}
\end{figure}



In total, if all four planes are used in their most complex form, up to eleven layers can compose the screen concurrently. 

An even more impressive feat from the CRT compositor is that all layers of each plane are independently hardware scrollable.

The numerous planes capabilities made the X68000 a versatile instrument able to excel at at wide range of task, from simple text editing to demanding raytracing. 

Video-games were obviously a strength of the machine thanks to its Background and Sprite layers although, as we will see, developers did not employ resources as one would expect.

% This page has really cool info \href{https://gamesx.com/wiki/doku.php?id=x68000}{here}. Also talk about coprocessor.


% The two last groups are managed by the X68000 custom Cynthia chip. 


% Its graphic system supporting 128 hardware 16x16 tiles surpassed both dedicated arcade hardware and home-console capabilities at the time it was released.



\subsubsection{OS}
Developed by Hudson Soft, the operating system named Human68k is stronly inspired by Microsoft's MS-DOS . 

All English name commands such as \icode{DIR} are present. In fact, Human68k manual is nearly identical to IBM DOS 4.0J manual\cite{human68k_manual}. The system even uses a \icode{CONFIG.SYS} file to boot.

\begin{figure}[H]
\img{human68k.png}
\caption*{X68000 OS, Human68k}
\end{figure}


Several windows based GUI running on top of Human68k were released over the years. In succession, "VS" then "Visual Shell" and later SX-WINDOW.

\begin{figure}[H]
\img{sx-window.png}
\caption*{SX-Window, GUI running on top of Human68k}
\end{figure}



\subsubsection{Development machine}
The similarities with the CPS-1 are many. Almost as if a software emulation layer would be enough to run a CPS-1 game. However a few details make the concept not as friction-less as it appears.

The sound chip is an OKI but it is "only" a MSM6258. Although it works alike the MSM6296 with ADPCM, it features only one channel which severely impact how rich the sound effects and music systems can be.

Most importantly, the Sprite system has a weakness. The number of tile displayable is half the capacity of the CPS-1 (128 instead of 256) but that is an issue easily circumvented thanks to techniques such as Sprite doubler by Koichi Yoshida\cite{x68000spritedoubler} relying on raster effect.

The real issue with the sprite system is the small amount of VRAM allowing to store only 256 tiles. A pity compared to the CPS-1 GFXROM allowing thousands. In these conditions, the limitation is to manage loading time from the floppy discs which access is quite slow and make a game unplayable if used during gameplay.

\subsubsection{Capcom ports}
These limitation did not deter Capcom from releasing five games for the platform, Ghouls 'n Ghosts, Final Fight, SF2CE, Super Street Fighter II, and Strider. 

 For some games developers were able to release "perfect port" which were visually identical to the arcade version. Capcom's Ghouls 'n Ghosts and Street Fighter 2 are considered perfect whereas in Final Fight the number of enemies on screen had to be lowered to handle loading time.

\subsubsection{Ports Analysis: Ghouls 'n Ghosts}
 Analysis\cite{x68k_games_analysis}

XM6 Pro-68k

\nbimg{x68k_gg_scr.png}

\begin{minipage}[t]{0.49\linewidth}
  \nbimg{x68k_gg_bitmap1.png}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \nbimg{x68k_gg_bitmap2.png}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \nbimg{x68k_gg_text.png}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \nbimg{x68k_gg_sprites.png}
\end{minipage}%

\pagebreak

\subsubsection{Ports Analysis: Final Fight}
Subway stairs
\pagebreak
Blac
\pagebreak

\subsubsection{Ports Analysis: Super Street Fighter II}
Need 4 MiB
\pagebreak
Blac
\pagebreak


\subsubsection{Rise and Fall}
 SHARP kept on improving the series with better CPU (68030), more RAM (up to 12MiB) and even HDD (up to 80 MiB). Peripheral manufacturers embraced the computer with extensions cards covering anything one can thing off. 

 In the end, SHARP bet was a phenomenal success. Users loved the platform dearly and publishers released, accounting for games only, no less than 823 titles between 1988 and 1999.

\nbdraw{68000_series}

% These machine left such an impression on users that, as of 2022, more than thirty years after the last X68000 came out of the factory, functioning models easily fetch \$2,600 on the secondary market.

The commitment to an aesthetic rooted in minimalism and simplicity expressed itself during the whole lifespan of the series, down to the pages of each SHARP catalogs. 

\img{SharpX68000ad.jpg}

 \begin{figure}[H]
\nbdraw{x68000series}
\caption*{All X68000 family members}
\end{figure}

\begin{trivia}
The success was such that a magazine dedicated to the x68000, Oh!X, was published from 1988 to 2000 over 139 volumes. 


\begin{minipage}[t]{0.32\linewidth}
  \draw{OhX_1990-04}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\linewidth}
 % \begin{figure}[H]
  \draw{OhX_1991-02}
  % \caption*{Oh!X covers}
% \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.322\linewidth}
  \draw{OhX_1990-10}
\end{minipage}%



Often featuring a raytraced cover to boast the graphic capabilities of the SHARP marvels, each publication came loaded with softwares, originally on one, then two, and later three 5.25" floppy disks \cite{ohXarticle}!
\end{trivia}

Ultimately, SHARP timid updates were not enough to keep even its most recent X68030 competitive. After six years without updating the video or audio hardware the IBM PC caught up. In 1993, many felt a great disturbance in the Force when SHARP discontinued the "god computer".

