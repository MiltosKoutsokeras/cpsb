\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its dependencies and the components it needs to communicate with. 

\begin{figure}[H]
\sdraw{1.0}{control_arch}
\caption*{The control system components}
\end{figure}

While the latch toward the Sound system is a small API surface, the GFX API is huge. The interface to the Graphic System is bigger both in breadth (it features 64 registers) and depth (the expected GFXRAM data layout is non-trivial).

To our advantage, the Motorola 68000 is a target supported by the GNU Compiler Collection (GCC). This suite features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

All stages of the build graph rely on a GNU GCC provided tool. Compiling of \icode{.c} code to \icode{.obj} is done via \icode{gcc} compiler. Assembling of \icode{.s} files to \icode{.obj} files is taken care of by \icode{as} assembler . Finally, the \icode{ld} linker combines all \icode{.obj} together into raw instructions. 


\nbdraw{build_graph_ctrl}



At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 Alike for the z80, bootrapping is solved with a small assembler program named \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it reads an array of 64 32-bit integers alled the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[style=m68kStyle]{src/code/68000/crt0.s}

All other slots except for one (offset \icode{26}) point to a no-nop routine.




\section{Auto-Interrupt}
The 68000 has multiple interrupt modes. In its most complex form, \icode{IPL0}, \icode{IPL1}, and \icode{IPL2} encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode, auto-vector, makes the CPU jump directly based on the three IPL lines state. Three lines are treated as bit giving a value in [0,7] which is used to looked up the "vector table" starting at offset \icode{24}.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{24 + 2 = 26}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt1.s}

The last piece is the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt2.s}






\section{Memory Map}
Alike for the Sound System and its z80 memory space, we need to make sure the software behaves accordingly to the memory map defined by the board PALs.

The compiler in the GNU Compiler Collection, \icode{gcc} does not have a placement keyword \icode{\_at} but even if it had been available, it would not have been enough to map large portion such as the 196 KiB of GFXRAM.

We can compensate for the lack of \icode{\_\_at} thanks to the power of \icode{ld}'s linker script system. The idea is to use a tow steps method where:
\begin{enumerate}
\item Define memory regions in the script thanks to the \icode{MEMORY} keyword. Create segments where code/data are stored in regions based on read/write access types.
\item Connect regions and segments in the C code.
\end{enumerate}


% As a reminded, here is the desired memory mapping.
\pagebreak

\subsection{Goal}
To avoid flipping pages, here is the memory map studied on page \pageref{m68k_mm}.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA players inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

\subsection{Memory Regions}
 % GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\begin{trivia}
Notice how powerful the linker script is compared to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using a container like \icode{elf}. This avoid the conversion step from elf to binary using \icode{objcopy}.
\end{trivia}


\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are assigned to a memory region by name.

\begin{trivia}
Notice the care taken to make sure the 68000 will only attempt to access aligned data via \icode{.ALIGN(4)} directives. Unaligned memory access is an unrecoverable error resulting in the 68000 \icode{HALT}ing.
\end{trivia}


\subsection{Code to segment}

C variables are placed into these sections using the names defined in the linker script.

\lstinputlisting[style=CStyle]{src/code/68000/memory_map.c}



\section{Initializing variables}
The linker script created markers and requested section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols as if they were in \icode{.ram} (LMA).

With these elements, zeroing the bss and populating .data with initial values is just a few lines of C.

\lstinputlisting[style=CStyle]{src/code/68000/init_vars.c}

\pagebreak
\section{Verifying RAM}
Capcom games bootstrap does more than bringing up the CPUs. They also verify the health of hardware components. These screens are rarely, if ever, seen by players since they are visible only once when the cabinet is turned on. During normal operations, that would be once a day when nobody is there.

All CPS-1 games display a slightly different set of text. However all of them check for faulty RAM access by the Control system. By checking the communication lines, the cabinet prevented wild bug hunt where a system would fault because it received corrupted messages. 

By allowing to quickly rules out a whole class of errors, the startup tests sped up debugging and brought down repairing costs.

The technique used is simple. For all byte in each areas of the RAM and GFXRAM, try to write a value, then try to read it back. If they differ, the GFXRAM is faulty and an error message is displayed. 

The limit of this technique is that only what is visible by the Control system can be verified. There is no way to checksum the GFXROM. While the z80 can access most of the Sound System ROM (except for the OKI ROM), it could perform checks but would have no way to surface errors since the latches can only be written from the m68k side.
\vfill
\begin{figure}[H]
\nbimg{boot_ghouls.png}
\caption*{Ghouls 'n Ghosts boot screen}
\end{figure}


\begin{figure}[H]
\nbimg{boot_sf2.png}
\caption*{Street Fighter 2 boot screen}
\end{figure}








% These tests look that something that would be standard and common to every games. Surprisingly they are all different and even differ between two titles made by a same team consecutively. The GFXRAM part of the RAM hosting the Palettes is not tested in Street Fighter 2 despite having been released after Final Fight.



\begin{figure}[H]
\nbimg{boot_forgottn.png}
\caption*{Forgotten Worlds boot screen}
\end{figure}



\vfill
\begin{figure}[H]
\nbimg{boot_ffight.png}
\caption*{Final Fight boot screen}
\end{figure}






\section{Ruling them all}
\label{this}
This is now \pageref{this} page in the "Book of CP-System". With each chapter peeling away a layer of complexity, we have finally reached the heart of the game. 

The function \icode{main} is where developers will have their game engine convert player inputs into visual and audio outputs.

The architecture is much alike the z80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened roughly every 16ms. Its job is to read inputs and save them locally, read latch buffer and write them to the latch, and more importantly, flip the GFXRAM double buffered descriptors. 

\begin{trivia}
The \icode{frameCounter} variable not only allow to pace the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible, it is also useful too keep track of wall-time to render animation and game logic properly.
\end{trivia}


\subsection{Commanding sound}
By now it will be abundantly clear that requesting a sound or a music playback is only about writing to a latch and forget about it. 

Special care has to occur if the engine may request multiple sound during a same frame. If this were to happen the value in the latch could be overwritten before the z80 picked it up.

The solution is to implement a system of queue where only one value is requested by frame.

However for the simplification and brevity requirement of this book, no queue is used in the following code.

\lstinputlisting[style=CStyle]{src/code/68000/vsync.c} 

\subsection{Main}
\lstinputlisting[style=CStyle]{src/code/68000/main.c} 

How \icode{hostframe} is implemented is completely at the programmer's discretion. Capcom games used a common kernel framework made of tasks. Since there is no source of interrupt beside \icode{vsync} they implemented a collaborative multi-tasking system where the stack and registers are stored/loaded as each task is executed.

To lean more about the Capcom kernel and how Street Fighter II uses it to multi-task A.I bytecode and moving fireballs make sure to checkout Street Fighter II Paladium source code\cite{sf2platinium}.

\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcades operator could configure the difficulty of a game via DIP switches. In a game like Street Fighter 2, eight configuration go from the easiest where 1 coin grants 6 credits to the hardest where four coins grant a single credit. There is even a "Free Play" mode which no amount of begging could convince operators to enable\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As featured on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value A.I selects "better" bytecode\cite{sf2aiengine} script. The A.I still cheat in all of them by skipping "charging"\cite{sf2aiengine}.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 % \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Map Zone }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMAp &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMAp &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMAp &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMAp &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMAc &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMAc &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMAc &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMAd &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
% \caption*{Input bit layouts}
% \end{figure}  

\subsection{Drawing on screen}
Requesting tiles to be drawn consist in first describing the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to tell them at what offset the data is.

\subsubsection{Double buffering}
When a frame is rasterized, neither the data in the GFXRAM nor the registers values can be changed. Otherwise it would result in inconsistent images. Changes should only occur during the VBLANKing which is signaled to the 68000 via the \icode{VSync} function.

The proper way to avoid visual artifacts is to use a double buffer in the GFXRAM where the currently used data is not written until the next VSYNC. Meanwhile the next frame is being prepared in the other buffer. 

On \icode{VSync} the CPS-A and CPS-B registers are written to point them to the next frame data.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the map and always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system define all these values.

Note that all registers are 16-bit wide to accommodate the 68000 writing to them. As shown in the summary table, a register offset is always located on an even address.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ base}  &  \texttt{0x00} & Sprite and Shape descriptors   \\   
\texttt{SCR1 base} &  \texttt{0x02}  & SCROLL1 descriptors   \\         
\texttt{SCR2 base} &  \texttt{0x04}  & SCROLL2 descriptors   \\     
\texttt{SCR3 base}&  \texttt{0x06}   & SCROLL3 descriptors  \\     
\texttt{ROWSCROLL base} &  \texttt{0x08}  & 256 rowscroll values   \\     
\texttt{Palette base} &  \texttt{0x0A}  & Palettes location   \\   
  \toprule   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & SCROLL1 Offset X  \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & SCROLL1 Offset Y    \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & SCROLL2 Offset X    \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & SCROLL2 Offset Y    \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & SCROLL3 Offset X    \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & SCROLL3 Offset Y    \\     
  \toprule   
\texttt{Star1    X} &  \texttt{0x18}  & STAR1   Offset X    \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & STAR1   Offset Y    \\  
\texttt{Star2    X} &  \texttt{0x1C}  & STAR2   Offset X    \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & STAR2   Offset Y    \\  
  \toprule   
\texttt{ROWSCROLL\_OFFSETS} &  \texttt{0x20}  & Offsets into ROWSCROLL base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers}
\end{figure}

The bases tell the CPS-A where it should expected data in GFXRAM. Registers are 16-bit but address must be 24-bit so values are \icode{<< 8}. 

Scroll offsets are exactly that with coordinates origin in the upper left.

Rowscrolling of SRC1 layer is achieved by two registers. Rowscroll base points to an array of 16-bit values. Rowscroll offset is an offset inside the base. This is elaborated on in the rowscroll section.


\paragraph{Video Control} This register enable/disable misc attributes.

\lstinputlisting[style=CStyle]{src/code/68000/videocontrol.c} 



All CPS-B registers location change based on the version.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and Order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  4 pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  4 pen values to draw above OBJ  \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers *for Street Fighter 2	(CPS-B 11)}
\end{figure}

\paragraph{Palette control}This register is used to upload palettes pages. A page is a group of 32 palettes belonging to a same layer.

\lstinputlisting[style=CStyle]{src/code/68000/palettecontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A wait until the next VBLANK.

The graphic chip does not use a fixed base + offset to lookup a Palette page. e.g: If \icode{SCR1} palette is not marked for upload, \icode{SCR2} palette is expected immediately after \icode{OBJ} palette.



\paragraph{Layer control} This register allows to enable or disable a layer individually (with the exception of OBJ which uses another way). It is also used to define the priority of layers \icode{OBJ}, \icode{SCR1}, \icode{SCR2}, and \icode{SC3} individually.

Note that STARs are always in the back and in order STAR1, STAR2.
  
\lstinputlisting[style=CStyle]{src/code/68000/layercontrol.c} 

The board studied in this book used CPS-B 11 which does not support STAR1 and STAR2. That feature was not used much besides in Forgotten Words (\icode{CPS-B 01}) and Strider (also \icode{CPS-B 01}).

\begin{trivia}
Starfields were used so little that the bytecode mapper was removed altogether from the CPS-2 while the ASICs retains the circuits.
\end{trivia}

Layer control register is also used to define the order in which OBJ, SCR1, SCR2, and SCR3 should be drawn.

\lstinputlisting[style=CStyle]{src/code/68000/layercontrol2.c} 

This bit layout never changes accross CPS-B.

\paragraph{Priority mask}
The layer located first behind the OBJ layer has the super power of being able to be draw on top of OBJ. Each tile must be marked as such (described in "Rendering SCROLLs" section) and the pen values to be treated specially are to be written in the priority mask registers. Four values can be entered in four registers.



\lstinputlisting[style=CStyle]{src/code/68000/maskcontrol.c} 






\subsubsection{Drawing Shapes and Sprites}
To drawing sprites and shapes, descriptors must be written to the GFX RAM. Each entry takes 8 bytes

\lstinputlisting[style=CStyle]{src/code/68000/sprites.c} 

The attribute two bytes have a special layout.

\lstinputlisting[style=CStyle]{src/code/68000/sprites2.c} 

The end of the list is marked with an entry using attribute value \icode{0xFF00}. 

If the attribute bytes indicate set block sizes to zero, a descriptor commands a simple tile to be drawn. The immense majority of draw calls in a Capcom games are single tile commands.

A shape is made of several single tile draw command resulting in arbitrary forms but a sprite must be rectangular. It is a single draw resulting in multiple tiles rendered but but it does not allow to draw more than the maximum limit of tiles.

The CSP-A will read up to 256 entries there and ignore the rest. This is a hardware limitation. There is no enough time in a raster scan to draw all tiles.

Developers do not have to worry about the \icode{STF29} or GFX partitioning. The tileID is relative to group it belongs to.

\subsubsection{Drawing SCROLLs}

Rendering tilemap is much alike rendering OBJs. Descriptors must be written to the GFX RAM. Each entry is two bytes wide.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls.c} 

The attribute byte is a bit field where we find in particular the palette ID, the group ID which references the priority mask, and the usual flippers.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls2.c} 

All SCROLLs have different size and tile size. But they all features 64x64 (4,096) entries. The CPS-A expects no more and no less. 
 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xrrr}
  \toprule    
  \textbf{Scroll name } & \textbf{ Tiles Dimensions } & \textbf{ Tile size }  & \textbf{Dimension }\\  
  \toprule   
    
\texttt{SCROLL1} & \texttt{64x64} & \texttt{8x 8 } &  \texttt{512x 512 }  \\  
\texttt{SCROLL2} & \texttt{64x64} & \texttt{16x16 } &  \texttt{1024x1024 }   \\  
\texttt{SCROLL3} & \texttt{64x64} & \texttt{32x32 } &  \texttt{2018x2048 }   \\  
  \toprule   
\end{tabularx}
\vspace*{-1mm} % Ugly hack to make release typeset be like debug. No idea why there is a difference.
\caption*{SCROLLS tile size and dimensions}
\end{figure}

% \begin{trivia}
As alluded in the hardware chapter,a  full back screen can be rendered without using a single scroll or OBJs.

Enabling the STAR1 layer without requesting any stars via the bytecode does the trick. It only works if the CPS-B on the board support STARfield (few do). Street Fighter II Champion Edition, a game using no STARfield, features a STARfield capable CPS-B vXX which is used in the popup logo scene.
% \end{trivia}



\subsubsection{Row Scroll}
Rowscrolling allows to offset each visible row via a discrete X amounts. In Street Fighter II, Honda's dohyō ( the space in which a sumo wrestling bout occurs) perspective is achieved via linear offset differences. The more perspective needed, the more accentuated is the offset slope. 

\begin{figure}[H]
\nbimg{ring_skew_none.png}
\caption*{Fighters at the center of the dohyō.}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_left.png}
\caption*{Fighters move to the left of the dohyō.}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_right.png}
\caption*{Fighters move to the right of the dohyō.}
 \end{figure}%

To scroll each row, the CPS-A reads 256 values. That is 224 (each visible lines) + 16 (one tile height above) + 16 (one tile heigh below) = 256 values to render a frame.

Each unsigned 16-bit offset value is expected in an array located in GFXRAM and pointed to via the CPS-A register \icode{ROWSCROLL\_BASE}.

The \icode{ROWSCROLL\_OFFSET} instructs the CPS-A to use values not starting at \icode{ROWSCROLL\_BASE} but at \icode{ROWSCROLL\_BASE} + \icode{ROWSCROLL\_OFFSET}. 

\begin{figure}[H]
\nbdraw{rowscroll}
 \caption*{CPS-A rowscroll data access}%
 \end{figure}%

A convenient trick is to allocate a rowscroll array of size 1024 with one entry for the full height of \icode{SCROLL2} and generate all the rowscroll offsets. If \icode{SCROLL2} is scrolled vertically, the engine only needs to manipulate \icode{ROWSCROLL\_OFFSET} and no new values are to be generated.

\lstinputlisting[style=CStyle]{src/code/68000/rowscroll.c} 

Trivia: No connection to HSYNC, this is fully hard-coded.

\subsubsection{Real-life example}

When a contestant in Street Figther II jumps, SCROLL2 moves vertically but no rowscroll offset are re-calculated, only \icode{ROWSCROLL\_OFFSET}  is moved. This allows to amortize the generation of perspective correct rowscroll offset.

Note that rowscroll offsets are unsigned and always indicate an amount to move toward the left side of the screen. To offset toward the right, Street Fighter II developers took advantage of the wrap around nature of the SCROLL layers and used \icode{decalValue = 1024 - desiredRightOffsetValue}.

% \begin{trivia}
% Honda's SCROLL2 features hidden message. It looks like the designers left construction block writings as Upper left, (\begin{CJK}{UTF8}{min}左上\end{CJK}), Upper middle (\begin{CJK}{UTF8}{min}中上\end{CJK}), and Upper right (\begin{CJK}{UTF8}{min}右上\end{CJK}) kanji can be spotted.
% \end{trivia}


















\pagebreak

\section{Back then...}\index{Back Then!Programming}
The system used by Capcom to program the CP-System remained unknown for many years. Only the nickname of Hiroaki Kondo, a composer/sound programmer often credited as "X68K", rumored a computer manufactured by Sharp. 

In 2018,  Akiman confirmed\cite{x68000usage1}\cite{x68000usage2} that Capcom's SDK, named CAT-1, was launched during the making of Street Fighter II and ran on a Sharp X68000.

\subsubsection{SHARP X68000}\index{Computers!SHARP X68000}

Unheard of in the rest of the world, the X68000 is a celebrity in Japan where it is called "god computer". 
Released in 1987, the first machine in the series was as beautiful and powerful as it was expensive (¥369,000, roughly \$3000 in 1987, equivalent to \$7,600 in 2022).

\vfill

 \begin{figure}[H]
\nbimg{68000.png}
\caption*{The SHARP, "God Computer", X68000 }
\end{figure}


Despite mind-blowing hardware specifications, SHARP's new product was a risky bet considering it had next to no software at launch. To complicate things further, it used its own text-based OS named Human68k.


\begin{wrapfigure}[37]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_front.png}
\end{wrapfigure}

The "Manhattan" twin-tower case of the first model became the signature of the series. 

Notice the vertical bar between the two towers. Pushing it down release a spring to allow the bar to extends past the top of the machine and become a carrying handle.


The most convenient ports for the keyboard, mouse, and joystick are conveniently user facing. An audio jack and a volume control are also present.

The two 5.25 floppy have elegant motorized "soft" ejection systems.

The three leds in the upper right indicates the state of the machine. If \icode{POWER} is self-explanatory, \icode{HIGH RESO} indicates whether the video output is using 15KHz, 24KHz, or 31kHz whereas \icode{TIMER} indicates if a self-powering is scheduled. 

In later revisions, \icode{HIGH RESO} was replaced with \icode{HD BUSY} to indicate HDD state.

Oh my God. It even has a front facing orange power button.

On the back panel can be found "standard" ports such as additional \icode{Line In} and \icode{Line Out}, and an extra \icode{Joystick \#2} entry.  packed with ports and extension points, illustrates the power of the workstation.

\pagebreak

\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_back.png}
\end{wrapfigure}



The \icode{TV Control} port allows to drive Sharp monitors and VCRs. It can take advantage of the timer mentioned earlier to schedule a tape recording.

The \icode{See through Color} port is for chroma-keying and rotoscoping.

A \icode{Image In} port for transferring images from a video device, such as a VCR.

A serial port, \icode{RS232C}, as found on many IBM PCs.



The \icode{HDD} and \icode{FDD} ports respectively allow Hard-Drive and Floppy-Drive extensions.

The \icode{100V out} outlet provides power for a monitor.

The \icode{Analog RGB out} port is the equivalent a VGA port to carry the monitor signal.


The \icode{Stereoscopic} port drives “shutter style” 3D glasses.

The \icode{Printer} port is a variant of the commonly called parallel port in USA only it is called Mini-Centronics 36-pin. 

For everything else, the X68000 features two \icode{extension slots} to welcome extension cards.

\textbf{Trivia:} The two \icode{FG} screws are meant for Frame Grounding since Japanese power outlets lack Ground wire and therefore a not grounded.


\pagebreak



\subsubsection{Tech specs}  
Inside its gorgeous "Manhattan" case, the machine packed an unparalleled amount of horse power. Even a machine such as the Amiga 500, released the same year and praised in Europe and USA for its prowess, pales in comparison to the X68000. 


 \begin{figure}[H]
\begin{tabularx}{\textwidth}{lXX}
  \toprule    
  \textbf{Type } & \textbf{ X68000 } & \textbf{ Amiga 500 }\\  
  \toprule   
    
CPU & M68000 10MHz & M68000 7.16 MHz\\  
RAM & 1MiB & 512 KiB\\
Max RAM & 4 MiB & 2 MiB\\ 
Colors  & 65,536 colors (stable) & 4,096 (HAM) \\
Resolution & 1024×1024 & 736x483 \\
% Graphics & 1 sprite plane, 2 bg planes, 4 bitmap planes& \\
Sprite engine & 128 units, 16x16 tiles & 8 units, 16x16 tiles\\
% Background engine & 2 in 256x256 \\
VRAM & 1056 KiB & -\\
Sound & Oki MSM6258 (1 channel)  & 4 channels PCM\\ 
Music & Yamaha YM2151 (8 channels)  & -\\ 
Price & \$5,000 & \$1,500 \\
% Storage & Dual 5.25 floppy readers  & \\ 
  \toprule   
\end{tabularx}
\caption*{X68000 vs Amiga 500}
\end{figure}


If both music and sound capabilities were outstanding, it is in the graphics department that the X68000 made jaws hit the floor.

The 1056 KiB of VRAM are divided into three segments feeding four planes. 512 KiB are dedicated to the Text plane, 512 KiB are for the Bitmap plane and the rest, 32 KiB, are for the joined use of the Background plane and Sprite plane. Each plane can be configured to host various resolution and layers.

\subsubsection{Video prowess}

The \textbf{Bitmap Plane} is particularly well suited to plot pixels and render images. Its direct 16bpp color mode was ideal for raytracing application (a M68881 math coprocessor could be added to reduce rendering time). 


\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 512x512 layer with direct 16bpp colors.
\item Two 512x512 layers with shared 8bpp indexed colors.
\item Four 512x512 layers with shared 4bpp indexed colors.
\item One 1024x1024 layer in 4bpp indexed colors.
\end{itemize}

The \textbf{Text Plane} is deceivingly named. It is a bitmap plane which unlike the bitmap plane, expects value accross bitplanes making it well suited to set a large quantity of bits with a single write. A 68000 writing a 16-bit word can set 16 pixels which makes text rendering very fast when copying characters from a model. 

\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 1024x1024 layer with 4bpp indexed colors.
\item Four 512x512 layers with 1bpp monochrome.
\end{itemize}


The \textbf{Background Plane} works as a tilemap. 
\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item Two 512x512 tilemaps using 8x8 tile with 4bpp indexed colors.
\item One 1024x1024 tilemap using 16x16 tiles with 4bpp indexed colors.
\end{itemize}

Finally, the \textbf{Sprite Plane} is a sprite layer allowing 128 sprite on-screen (with a max of 32 sprites per scanlines). Each sprite uses 4bpp indexed color (within 16 palettes).


 \begin{figure}[H]
\nbdraw{z68k_layers}
\caption*{X68000 planes and layers}
\end{figure}



In total, if all four planes are used in their most complex form, up to eleven layers can compose the screen concurrently. 

An even more impressive feat from the CRT compositor is that all layers of each plane are independently hardware scrollable.

The numerous planes capabilities made the X68000 a versatile instrument able to excel at at wide range of task, from simple text editing to demanding raytracing. 

Video-games were obviously a strength of the machine thanks to its Background and Sprite layers although, as we will see, developers did not employ resources as one would expect.

% This page has really cool info \href{https://gamesx.com/wiki/doku.php?id=x68000}{here}. Also talk about coprocessor.


% The two last groups are managed by the X68000 custom Cynthia chip. 


% Its graphic system supporting 128 hardware 16x16 tiles surpassed both dedicated arcade hardware and home-console capabilities at the time it was released.



\subsubsection{OS}
Developed by Hudson Soft, the operating system named Human68k is strongly inspired by Microsoft's MS-DOS . 

All English name commands such as \icode{DIR} are present. In fact, Human68k manual is nearly identical to IBM DOS 4.0J manual\cite{human68k_manual}. The system even uses a \icode{CONFIG.SYS} file to boot.

\begin{figure}[H]
\img{human68k.png}
\caption*{X68000 OS, Human68k}
\end{figure}


Several windows based GUI running on top of Human68k were released over the years. In succession, "VS" then "Visual Shell" and later SX-WINDOW.

\begin{figure}[H]
\img{sx-window.png}
\caption*{SX-Window, GUI running on top of Human68k}
\end{figure}



\subsubsection{A Development machine?}
The similarities between the X68000 and the CPS-1 are many. A quick glance over the specs could easily lead to conclude that a small layer of emulation is all a X68000 need to run CPS-1 games, making it a perfect development machine.

Since developers never elaborated to which extends SHARP's machine were used to make games, we can only make an educated guess.

The first element of response are the hardware components of the X68000. If the Motorola 680000 CPU and the Yahama 2151 are identical, the rest diverge rather significantly.

The sound chip is an OKI but it is "only" a MSM6258. Although it works alike the MSM6296 with ADPCM, it features only one channel which severely impact how rich the sound effects and music systems can be.

The sprite system is also, at first sight, weaker since the number of tile displayable is half the capacity of the CPS-1 (128 instead of 256). However that is an issue easily circumvented thanks to techniques such as Sprite doubler by Koichi Yoshida\cite{x68000spritedoubler} relying on raster effect.

Lastly, there is the issue of storage and loading time from the floppy drives, a notoriously slow medium. To solve this issue, X68000 developers often resulted to loading all assets to RAM between levels, which increased the RAM requirements of a title.

\subsubsection{32 KiB VRAM wall}

The real issue for all Capcom ports was the amount of VRAM availale to the sprite and tilemap systems. Where a CPS-1 game ships with a minimum of 2MiB ROM storing the GFX assets, the X68000 can only uses 32KiB out of the 1MiB of VRAM for the same purpose. 

This small amount effectively keepcap the idea of using both the Sprite and Tilemap system simulataneously since one of them would starve for tiles. 

\subsubsection{Learning from X68000 ports}

The limited amount of VRAM prevented the X68000 from being a CPS-1 emulator and likely relegated it to autor/test 68000 ASM, run a port of TCE for GFX integration, and allocate/compile the GFXROM for CPS-2 games. 

This theory is further reinforced by the study of five games ports by Capcom.

\begin{figure}[H]

\begin{tabularx}{\textwidth}{lrY}
  \toprule    
  \textbf{Game } & \textbf{ Year released}  & \textbf{Requirements } \\               
  \toprule   
  Strider & \texttt{1992} &  2 MiB \\
  Final Fight & \texttt{1992} &  2 MiB \\
  Street Fighter 2 Champion Edition & \texttt{1993} &  2 MiB \\
  Super Street Fighter II & \texttt{1994} &  4 MiB \\
  Ghouls'n Ghosts & \texttt{1994} &  2 MiB \\
    \toprule   
\end{tabularx}
\caption*{X68000 Ports of CPS-1 games by Capcom}
\end{figure}

None of these titles exhibit the common pattern of an emulation layer. On the contrary, the architecture of the GFX rendere is tailor each time, sometimes even differing between levels of a same title. 

Thanks to the awesome XM6 Pro-68k, we can study the GFX composition\cite{x68k_games_analysis} and see how rendering was often done in software which stresses the 68000. Accordingly, the manual of Ghouls 'n Ghosts recommends a 16MHz CPU and warns about slowdown with a machine using a 10MHz 68000.

\nbimg{gg_manual.jpg}


\subsubsection{Ports Analysis: Ghouls 'n Ghosts (1994)}
Ghouls 'n Ghosts was released in 1994, six years after its arcade release. It is noteworthy for its low RAM requirements of 2MiB RAM and its resolution of 512x512 which is higher than the 384x224 arcade cabinet. 

It is considered a "Perfect port" because of its GFX faithfulness to the CPS-1 version even though its graphic renderer is completely different. Tilemaps are not used at all since the background lives in two software rendered 512x512 Graphic layers using a shared 8-bit indexed colors palette. 

The Text layer is also fully software rendered. Because it is used in 16 colors mode, plotting pixels is expensive. The cost and low colors makes it a good fit for the GUI where few items and few colors are used.

\begin{figure}[H]
\img{x68k_gg_scrw.png}
\caption*{Ghouls 'n Ghosts on SHARP x68000}
\end{figure}


Notice the vertical "cut" in the right of Graphic plane Pages 0 and 1. This artifact reveals the usage of hardware scrolling and its wraparound. This allows the CPU to render only new portion of the scrolling. 

The rain effect is replicated as seen on page X by alternating the offset in the Text layer. The sprite layer must overlap exactly with Page 0 when the wind animates the grass.

There is no DMA support toward the VRAM so every single pixel except for the Sprite layer, is plotted by the CPU. Thank to hardware scrolling, the cost of rendering a whole screen is amortized over several frames which allows to reach a descent framerate.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_gg_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak

\subsubsection{Ports Analysis: Final Fight (1992)}

Final Fight was released in 1992, three years after its arcade release. Alike, Ghouls'n Ghosts the arcade version used 2MiB of GFXROM and managed to ship on two 5.25-inch 1.2 MiB floppies.

The graphic renders uses the same technique as Ghouls 'n Ghosts where the tilemaps are not used in order to feed the Sprite layer. Two bitmap layers along with a Text layer are rendered in software for a graphic result faithful to the orignal version.

The port is not "perfect" since the number of opponents on screen was restricted to 5 which is less than the arcade version where up to 8 enemies where visible. In all likelihood, this was done to lower the 32 KiB VRAM stress.

The trick describe on page \pageref{finalfight_trick} where part of the stair case must appear on front of the Sprite is done with a special blending mode. The MSBs indicates precedence over the Sprite layer. This leaves 7bpp for the color indexes. The Background end up using 128 colors instead of 256.

\begin{figure}[H]
\img{x68k_ff_scr.png}
\caption*{Final Fight on X68000}
\end{figure}


In the other levels, this blending mode is not used so the Bitmap layers go back to using 8bpp for a total of 256 colors available.

Thanks to the X68000's 2151, musics are close to the arcade version, except for the lack of embelishment from the OKI6295. To address this shortcoming, the game supports MIDI audio playback if a MIDI capable device is connected.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_ff_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak
\subsubsection{Ports Analysis: Street Fighter II Champion Edition (1993)}
Street Fighter II Champion Edition was released only a few after the arcade version, Capcom likely being motivated by the collosal success of the series.

The volume of assets forced the title into being shipped over four 5.25-inch 1.2 MiB floppies. The game manages to run with 2 MiB or RAM but suffers numerous loading, including between opponents. However, on a machine with 4MiB the game engine loads all floppies to RAM to provide a loadingless experience in-game.

In terms of GFX rendering, we find, again, software rendered layers. The floor however and its per-line parallax is not done via software. The X68000 is notified of HSYNC events from the video system and the hardware scroll is adjusted accordingly. This technique allows to render Page 0 once for all and never touch it.

When fighting occurs in Thailland, Text layer is used to render decorative Sprite such as the statue. It is likely that the 32 KiB was once again not big enough to contain the sprites for both opponents and decorations.

\begin{figure}[H]
\img{x68k_sf2ce_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\pagebreak

Notice the noise in the Graphic layers, the bottom part in Page 0 and the top part in Page 1. 

The programmers used every venues willing to welcome assetes in order to avoid loading from the floppy drives. The parts of the pages not used for composition are used to "cache" background tiles. When the CPU renders, it transfers VRAM to VRAM (sadly without DMA).

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap0.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%

\pagebreak

Investigating further into Street Fighter 2: Champion Edition confirms the colossal work that went into converting a CPS-1 title to X68000. 

\subsubsection{Per level renderer}
Where in Final Fight, the background color space was modified on a per-level basis, here each level uses a different rendering strategy to replicate the arcade peculiarities as well as possible.

When fighting occurs in China, the Text layer is not used for Sprite decoration anymore. Instead it is dedicated to the sky and its animation. Two rows of clouds, accounting for two "frames" animation are drawn once and the hardware offset is leveraged to render the animation. This was likely done because of the high fillrate required to update this whole layer.


If we look further, we see that Page 1 is used for the street even though no parallax is used. Again, this was likely done in order to spare the CPU.

\begin{figure}[H]
\img{x68k_sf2ce2_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
\begin{figure}[H]
\img{x68k_sf2ce2_bitmap0.png}
\caption*{512x512 Graphic Plane Page 0}
\end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
  \begin{figure}[H]
  \img{x68k_sf2ce2_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce2_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce2_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%



\subsubsection{Rise and Fall}
 SHARP kept on improving the series with better CPU (68030), more RAM (up to 12MiB) and even HDD (up to 80 MiB). Peripheral manufacturers embraced the computer with extensions cards covering anything one can thing off. 


\begin{figure}[H]
\nbdraw{68000_series}
\caption*{Sharp X68000 series 1987-1993}
\end{figure}






 SHARP bet was a phenomenal success. Users loved the platform dearly and publishers released, accounting for games only, no less than 823 titles between 1988 and 1999.




Ultimately, SHARP timid updates were not enough to keep even its most recent X68030 competitive. 

After six years without updating the video or audio hardware the IBM PC caught up. In 1993, many felt a great disturbance in the Force when SHARP discontinued the "god computer".

\begin{trivia}
The success was such that a magazine dedicated to the x68000, Oh!X, was published from 1988 to 2000 over 139 volumes. 

\begin{minipage}[t]{0.32\linewidth}
  \draw{OhX_1990-04}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\linewidth}
 % \begin{figure}[H]
  \draw{OhX_1991-02}
  % \caption*{Oh!X covers}
% \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.322\linewidth}
  \draw{OhX_1990-10}
\end{minipage}%

Often featuring a raytraced cover to boast the graphic capabilities of the SHARP marvels, each publication came loaded with softwares, originally on one, then two, and later three 5.25" floppy disks \cite{ohXarticle}!
\end{trivia}