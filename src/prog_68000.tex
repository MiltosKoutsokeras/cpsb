\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its interaction. 

\begin{figure}[H]
\sdraw{1.0}{cps1_arch}
\caption*{The one to rule them all}
\end{figure}

If the latch toward the Sound system are small registers, we will see that the GFXRAM, the interface to the GFX System is bigger both in breadth (it features 64 registers) and depth (the API is non-trivial).

Luckily, the 68000 is supported by the  GNU Compiler Collection (GCC). It features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

\nbdraw{build_graph_ctrl}


Nothing particularly difficult in the build graph. GCC is responsible for the entire pipeline with \icode{gcc} compiling C files to obj, \icode{as} assembling S files to obj, and \icode{ld} linking it all together. 

At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 The build graph on the next figure shows that the issues of bootrapping is solved like on the Z-80 with a small assembler programmer \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it consults a 64 32-bit integer array called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}

All other slots except one point to a no-nop routine.




\section{Auto-Interrupt}
Alike the Z-80, the 68000 has multiple interrupt modes. In its most complex form, IPL0, IPL1, and IPL2 encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode is called auto-vector. Here there are not interrupt level. The IPL lines encode an interrupt ID directly that is looked up in the "vector table" starting at offset 24.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{26}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt1.s}

The last piece of the interrupt puzzle is to write the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt2.s}






\section{Memory Map}
As a reminded, here is the desired memory mapping.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA players inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

 GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are signed to a memory region by name.

\lstinputlisting[language=C]{src/code/68000/memory_map.c}

\begin{trivia}
Notice how powerful the linker script can be compred to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using container like \icode{elf}. This avoid the need for an extra conversion using \icode{objcopy}.
\end{trivia}

\section{Initializing variables}
The linker script created markers and requeted section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols as if they were in \icode{.ram} (LMA).

With these elements, zeroing the bss and populating .data with inital values is just a few lines of C.

\lstinputlisting[language=C]{src/code/68000/init_vars.c}



\section{Ruling them all}
150 pages in, peeling layers one after one another and we have finally reached the heart of the game. Function \icode{main} is where developer trigger their game engine to convert inputs into visual ans audio ouputs.

The architecture is much alike the Z-80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened roughly every 16ms. Its job is to read inputs and save them locally, read latch buffer and write them to the latch, and more importantly, flip the GFXRAM descriptor. 

\begin{trivia}
The \icode{frameCounter} variable not only allow to pace the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible, it is also useful too keep track of wall-time to render animation and game logic properly.
\end{trivia}

Most importantly, flip the double GFXRAM buffer.

\subsection{Commanding sound}
By now it will be abondantly clear that requesting a sound or a music playback is only about writing to a latch and forget about it. Special care has to occur if the engine may request multiple sound during a same frame. If this were to happen the value in the latch could be overwritten before the Z-80 picked it up.

The solution is to implement a system of queue where only one value is requested by frame.

\pagebreak

\lstinputlisting[language=C]{src/code/68000/main.c} 


\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcades operator could configure the difficulty of a game via DIP switches. In a game like Street Fighter 2, eight configuration go from the easiest where 1 coin grants 6 credits to the hardest where four coins grant a single credit. Moreover, operator could disable "Continue coins"\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As featured on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value A.I selects bytecode\cite{sf2aiengine} script.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Map Zone }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMAp &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMAp &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMAp &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMAp &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMAp &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMAp &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMAp &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMAp &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMAc &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMAc &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMAc &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMAc &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMAd &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMAd &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
\caption*{Input bit layouts}
\end{figure}

\subsection{Drawing on screen}
Requesting tiles to be drawn consiste in first descring the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to tell them at what offset the data is.

\subsubsection{Double buffering}
When an image is rendered, neither the data in the GFXRAM nor the registers values can be changed. Otherwise it would result in inconsistent images. Changes should only occur during the VBLANKing which is signaled to the 68000 in \icode{VSync} function.

A proper way is to us a double buffer in the GFXRAM where the currenly used data is not touched while the next one is being prepared. On \icode{VSync} the CPS-A and CPS-B registers are written to point them to the next frame data.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the map and always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system define all these values.

Note that all registers are 16-bit wide to accomodate the 68000 writing to them.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ RAM base}  &  \texttt{0x00} & Bla   \\   
\texttt{SCR1 RAM base} &  \texttt{0x02}  & Bla   \\         
\texttt{SCR2 RAM base} &  \texttt{0x04}  & Bla   \\     
\texttt{SCR3 RAM base}&  \texttt{0x06}   & Bla  \\     
\texttt{ROWSCROLL RAM base} &  \texttt{0x08}  & 256 rowscroll values   \\     
\texttt{Palette base} &  \texttt{0x0A}  & Bla   \\   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & Bla   \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & Bla   \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & Bla   \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & Bla   \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & Bla   \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & Bla   \\     
\texttt{Star1    X} &  \texttt{0x18}  & Bla   \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & Bla   \\  
\texttt{Star2    X} &  \texttt{0x1C}  & Bla   \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & Bla   \\  
\texttt{ROWSCROLL\_OFFSETS} &  \texttt{0x20}  & Offsets into ROWSCROLL base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers}
\end{figure}

Because all registers are 16-bit but address for the base must be 24-bit, values written in base register are right-shifted \icode{<< 8}. 

All scroll offset coordinates origin are in the upper left.

rowscrool coordinate

\paragraph{Video Control} layout features

\pagebreak

All CPS-B registers location change based on its version.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and Order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  Bits meaning vary   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  Bits meaning vary   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  Bits meaning vary   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  Bits meaning vary   \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers *for Street Fighter 2	}
\end{figure}

\paragraph{Palette control}This register is used to upload palettes pages. A page is a group of 32 palettes belonging to a same layer.

\lstinputlisting[language=C]{src/code/68000/layercontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A wait until the next VBLANK. The graphic chip does not use a fixed base + offset to lookup a Palette page. e.g: If \icode{SCR1} palette is not marked for upload, \icode{SCR2} palette is found immediately after \icode{OBJ} palette.

Priority mask

\paragraph{Layer control} This register is used to enable/disable a layer but also to define the order in which layers should be drawn.


\subsubsection{Drawing Shapes and Sprites}
\subsubsection{Drawing SCROLLs}
\subsubsection{Drawing STARs}


\subsubsection{Back then...}
Very little has transpired.
\pagebreak

dsa

\simg{0.53}{x68000_XVI.png}
\pagebreak

Talk about perfect ports.

\img{SharpX68000ad.jpg}

\section{Easter eggs}
720 block
Red Fireball