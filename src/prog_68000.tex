\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its interaction. 

\begin{figure}[H]
\sdraw{1.0}{cps1_arch}
\caption*{The one to rule them all}
\end{figure}

If the latch toward the Sound system are small registers, we will see that the GFXRAM, the interface to the GFX System is bigger both in breadth (it features 64 registers) and depth (the API is non-trivial).

Luckily, the 68000 is supported by the  GNU Compiler Collection (GCC). It features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

\nbdraw{build_graph_ctrl}


Nothing particularly difficult in the build graph. GCC is responsible for the entire pipeline with \icode{gcc} compiling C files to obj, \icode{as} assembling S files to obj, and \icode{ld} linking it all together. 

At the end of the process, the logical 68000 ROM is split and interleaved in chip sized ROMs according to what was described in the hardware chapter.

 The build graph on the next figure shows that the issues of bootrapping is solved like on the Z-80 with a small assembler programmer \icode{crt0.s}.

\section{Bootstrapping the 68000}
A 68000 does not have a set booting address. Instead, it consults a 64 32-bit integer array called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt0.s}

All other slots except one point to a no-nop routine.




\section{Interrupt}
Alike the Z-80, the 68000 has multiple interrupt modes. In its most complex form, IPL0, IPL1, and IPL2 encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the talks at hand.

A simpler mode is called auto-vector. Here there are not interrupt level. The IPL lines encode an interrupt ID directly that is looked up in the "vector table" starting at offset 24.

Since IPL1 is connected to the CPS-A INT lines, the VSYnc handler function is placed at offset \icode{26}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt1.s}

The last piece of the interrupt puzzle is to write the \icode{\_boot} function, which setups auto-vector and jump to \icode{main}.

\lstinputlisting[language={[Motorola68k]Assembler}]{src/code/68000/crt2.s}






\section{Memory Map}
No \icode{\_\_at} support so leveral powerful GCC linker script 

\lstinputlisting[]{src/code/68000/cps1.lk}
Notice how the linker script allow to directly output raw binary without a container like \icode{elf}.

\section{Initializing variables}

\pagebreak

\section{Ruling them all}
\section{GFX assets for the gfx system}
\section{Double buffering}
\section{Color brightness}
\section{Drawing shapes}
\section{Drawing sprites}
\section{Drawing SCR1}
\section{Drawing SCR2}
\section{Drawing SCR3}
\section{Drawing STAR1}
\section{Drawing STAR2}

\section{Back then...}
Very little has transpired.
\pagebreak

dsa

\simg{0.53}{x68000_XVI.png}
\pagebreak

Talk about perfect ports.

\img{SharpX68000ad.jpg}

\section{Easter eggs}
720 block
Red Fireball