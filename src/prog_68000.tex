\chapter{Control System}
The control system is the simplest ROM to build since it involves only compiling code and the hardest to get right because of the complexity of its dependencies and the components it needs to communicate with. 

\begin{figure}[H]
\sdraw{1.0}{control_arch}
\caption*{The control system components}
\end{figure}

While the latch toward the Sound system is a small API surface, the GFX API is huge. The interface to the Graphic System is bigger both in breadth (it features 64 registers) and depth (the expected GFXRAM data layout is non-trivial).

To our advantage, the Motorola 68000 is a target supported by the \textbf{G}NU \textbf{C}ompiler \textbf{C}ollection (GCC). This suite features a much more powerful linker script system than \icode{sdcc} which helps considerably to solve the memory mapping requirements.

All stages of the build graph rely on tools provided by GNU GCC. Compiling \icode{.c} code to \icode{.obj} is done via \icode{gcc} compiler. Assembling \icode{.s} files to \icode{.obj} files is taken care of by \icode{as} assembler . Finally, the \icode{ld} linker combines all \icode{.obj} together into raw instructions. 


\nbdraw{build_graph_ctrl}



At the end of the process, the logical m68k ROM is split into interleaved chip sized ROMs according to the specific of the target board (described in the hardware chapter).

 Alike for the z80, bootstrapping is solved with a small assembler program named \icode{crt0.s}.

\section{Bootstrapping the 68000}
Contrary to a z80, a m68k does not have a set booting address. Instead, it reads an array of 64 32-bit integers called the "vector table". Located at \icode{0x000000}, this is where the CPU find the values to initialize its registers such as the stack pointer (offset \icode{0}) and instruction pointer (offset \icode{1}).

\lstinputlisting[style=m68kStyle]{src/code/68000/crt0.s}

All other slots except for one (offset \icode{26}) point to a no-nop routine.




\section{Auto-Interrupt}
\index{Interrupts!Programming 68000}
The 68000 has multiple interrupt modes. In its most complex form, \icode{IPL0}, \icode{IPL1}, and \icode{IPL2} encode a level of interrupt and the interrupt ID is retrieved via an external interrupt controller. This would be over-kill for the task at hand.

A simpler mode, auto-vector, makes the CPU jump directly based on the three IPL lines state. Three lines are treated as bit giving a value within [0,7] which is used to looked up the "vector table" starting at offset \icode{24}.

The 3-bit scheme uses \icode{IPL0} for bit 0, \icode{IPL1} for bit 1, and \icode{IPL2} for bit 2. With CPS-A INT only connected to \icode{IPL1}, handler \#2 is always called upon interrupt. Therefore, VSync must be placed at offset \icode{24 + 2 = 26}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt1.s}

The last piece of the \icode{\_boot} function, sets up auto-vector mode and jump to \icode{main}.

\lstinputlisting[style=m68kStyle]{src/code/68000/crt2.s}






\section{Memory Map}
Alike for the Sound System and its z80 memory space, we need to make sure the software behaves accordingly to the memory map defined by the board PALs.

The compiler in the GNU Compiler Collection, \icode{gcc} does not have a placement keyword \icode{\_at} but even if it had been available, it would not have been enough to map large portion such as the 196 KiB of GFXRAM.

We can compensate for the lack of \icode{\_\_at} thanks to the power of \icode{ld}'s linker script system. The idea is to use a two steps method where:
\begin{enumerate}
\item Define memory regions in the script thanks to the \icode{MEMORY} keyword. Create segments where code/data are stored in regions based on read/write access types.
\item Connect regions and segments in the C code.
\end{enumerate}


% As a reminded, here is the desired memory mapping.
\pagebreak

\subsection{Goal}
To avoid flipping pages, here is the memory map studied on page \pageref{m68k_mm}.

\begin{tabularx}{\textwidth}{rrrX}
\toprule    
  \textbf{Start } & \textbf{End  } & \textbf{Size } & \textbf{Function } \\               
  \toprule    
  \texttt{0x000000} & \texttt{0x3FFFFF} & 3 MiB & ROM \\
  \toprule    
  \texttt{0x800000} & \texttt{0x800007} & 8 B & JAMMA Players Inputs \\
  \texttt{0x800018} & \texttt{0x80001F} & 8 B & JAMMA Dip Switches \\
  \texttt{0x800030} & \texttt{0x800037} & 8 B & JAMMA Coin sensors \\
  \texttt{0x800176} & \texttt{0x800177} & 1 B & Kick harness \\
\toprule    
  \texttt{0x800100} & \texttt{0x80013f} & 64 B & CPS-A registers\\
  \texttt{0x800140} & \texttt{0x80017f} & 64 B & CPS-B registers\\
\toprule    
  \texttt{0x800180} & \texttt{0x800187} & 8 B & Sound commands (latch 1)\\
  \texttt{0x800188} & \texttt{0x80018F} & 8 B & Sound commands (latch 2)\\
  \toprule    
  \texttt{0x900000} & \texttt{0x92FFFF} & 196 KiB & GFXRAM\\
  \texttt{0xFF0000} & \texttt{0xFFFFFF} & 64 KiB & RAM \\
  \toprule    
\end{tabularx}%

\subsection{Memory Regions}
 % GCC's powerful linker script allows to define memory region.

\lstinputlisting[]{src/code/68000/cps1.lk}

\begin{trivia}
Notice how powerful the linker script is compared to \icode{sdcc}. A directive, \icode{OUTPUT\_FORMAT (" binary ")} allows to directly output raw binary without using a container like \icode{elf}. This avoid the conversion step from elf to binary using \icode{objcopy}.
\end{trivia}


\lstinputlisting[]{src/code/68000/cps1-2.lk}

In the second part of the script, sections are assigned (via \textbf{\red{\textgreater}}) to a memory region using their \red{MEMORY} name.

\begin{trivia}
Notice the care taken to make sure the 68000 will only attempt to access aligned data via \icode{.ALIGN(4)} directives. Unaligned memory access is an unrecoverable error resulting in the 68000 \icode{HALT}ing.
\end{trivia}


\subsection{Code to segment}

C variables are placed into these sections using the names defined in the linker script.

\lstinputlisting[style=CStyle]{src/code/68000/memory_map.c}



\section{Initializing variables}
The linker script created markers and requested section \icode{.data} to be written to \icode{rom} (VMA) but relocate symbols (via \textbf{\red{AT\textgreater}}) as if they were in \icode{ram} (LMA).

With these elements, zeroing the bss and populating \icode{.data} with initial values is just a few lines of C.

\lstinputlisting[style=CStyle]{src/code/68000/init_vars.c}

\pagebreak
\section{Verifying RAM}
Our bootloader is simple but the ones used by Capcom did more than bringing up the CPUs. They also verify the health of hardware components. These screens are rarely, if ever, seen by players since they are visible only once when the cabinet is turned on. During normal operations, that would be when nobody is there.

All CPS-1 games display a slightly different set of text. However all of them check for faulty RAM access by the Control system. By checking the communication lines, the cabinet prevented wild goose bug hunt where a sub-system would fault because it received corrupted messages. 

By allowing to quickly rules out a whole class of errors, the startup tests sped up debugging and brought down repairing costs.

The technique used is simple. For all bytes in each areas of the RAM and GFXRAM, the m68k tries to write a value, then try to read it back. If they differ, the memory is faulty and an error message is displayed. 

The limit of this technique is that only what is visible by the Control system can be verified. There is no way to checksum the GFXROM. While the z80 can access most of the Sound System ROM (except for the OKI ROM), it could perform checks but would have no way to surface errors since the latches can only be written from the m68k side.
\vfill
\begin{figure}[H]
\nbimg{boot_ghouls.png}
\caption*{Ghouls 'n Ghosts boot screen}
\end{figure}


\begin{figure}[H]
\nbimg{boot_sf2.png}
\caption*{Street Fighter 2 boot screen}
\end{figure}










\begin{figure}[H]
\nbimg{boot_forgottn.png}
\caption*{Forgotten Worlds boot screen}
\end{figure}



\vfill
\begin{figure}[H]
\nbimg{boot_ffight.png}
\caption*{Final Fight boot screen}
\end{figure}






\section{Ruling them all}
With each chapter peeling away a layer of complexity, we have finally reached the heart of the CP-System. 
The function \icode{main} is where developers will have their game engine convert player inputs into visual and audio outputs.

The architecture is much alike the z80 sound system where two "threads" run in lockstep. Function \icode{VSync} is awakened every 16ms via an interrupt. Its job is to read inputs and save them locally, read sound/music requests and write them to the latch. More importantly, it flips the GFXRAM double buffered SCROLL and OBJ descriptors. 

\begin{trivia}
The \icode{frameCounter} variable paces the main thread so a new frame is only hosted every 16ms instead of rendering as fast as possible. It is also useful to keep track of wall-time to render animation and game logic properly.
\end{trivia}


\subsection{Commanding sound}
Requesting a sound or a music playback is only about writing to a latch and forget about it. However special care is necessary if the engine requests multiple sounds during a same frame. If this were to happen the value in the latch could be overwritten before the z80 picked it up.
The solution is to implement a system of queue where commands are stored and fed one by one every frame. 

Functions \icode{VSync} and \icode{main} run in lock-steps via two counters. Main only runs after a sync has occurred. \icode{Sync} is always one step ahead of main function.

\lstinputlisting[style=CStyle]{src/code/68000/vsync.c} 

\subsection{Main}
\lstinputlisting[style=CStyle]{src/code/68000/main.c} 


How \icode{hostframe} is implemented is completely at the programmer's discretion. Capcom games used a common kernel framework made of tasks. Since there is no source of interrupt beside \icode{vsync} they implemented a collaborative multi-tasking system where the stack and registers are stored/loaded as each task is executed.

To learn about the kernel and how it is used to run multi-task A.I bytecode and moving fireballs, checkout Street Fighter II Paladium source code\cite{sf2platinium}.

\subsection{Retrieving inputs}
Besides joystick and buttons, the engine must recover inputs such as the dip settings, P1Start, P2Start, and most importantly detect coins being inserted.

\begin{trivia}
Arcades operator could configure the difficulty of a game via DIP switches. In Street Fighter 2, eight configurations go from the easiest where 1 coin grants six credits to the hardest where four coins grant a single credit. There is even a "Free Play" mode which no amount of begging could convince them to enable\cite{sf2manual}.
\end{trivia}

The three DIP switches are called A, B, and C. As visible on page \pageref{fig:boarda} each DIP has 8 switches responsible for flipping a bit in a byte. Recovering the configuration is as simple as reading a byte from the memory map.

\begin{trivia}
In Street Fighter 2, DIP B is used to configure the difficulty level of the game ranging from 0 to 8 (4=default). Based on this value the A.I selects appropriates set of bytecode\cite{sf2aiengine} script. Even in easy mode, the A.I cheats by skipping "charging"\cite{sf2aiengine}.
\end{trivia}



 % \href{https://github.com/originalgrego/FinalFightAE-Source/blob/master/docs/known_addresses.txt}
 % \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xllr}
  \toprule    
  \textbf{Label } & \textbf{ Memory Area }  & \textbf{Address } & \textbf{Mask } \\               
  \toprule   
  
    \texttt{P1\_KEY\_3} & JAMMA Players Inputs &    \texttt{0x800000} &  \texttt{0b01000000}    \\ 
      \texttt{P1\_KEY\_2} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00100000}    \\  	
    \texttt{P1\_KEY\_1} & JAMMA Players Inputs &    \texttt{0x800000} &  \texttt{0b00010000}    \\     
  \texttt{P\_UP}    & JAMMA Players Inputs &        \texttt{0x800000} &  \texttt{0b00001000}    \\     
  \texttt{P1\_DOWN} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000100}    \\     
  \texttt{P1\_LEFT} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000010}    \\     
  \texttt{P1\_RIGHT} & JAMMA Players Inputs &  \texttt{0x800000} &  \texttt{0b00000001}    \\     
 
  \toprule   
    \texttt{P2\_KEY\_3} & JAMMA Players Inputs &  \texttt{0x800001}    &  \texttt{0b01000000}    \\     
  \texttt{P2\_KEY\_2} & JAMMA Players Inputs &  \texttt{0x800001}    &    \texttt{0b00100000}    \\     
  \texttt{P2\_KEY\_1} & JAMMA Players Inputs &  \texttt{0x800001}    &    \texttt{0b00010000}    \\    
  \texttt{P2\_UP}    & JAMMA Players Inputs &  \texttt{0x800001}    &     \texttt{0b00001000}    \\     
  \texttt{P2\_DOWN} & JAMMA Players Inputs &  \texttt{0x800001}    &      \texttt{0b00000100}    \\     
  \texttt{P2\_LEFT} & JAMMA Players Inputs &  \texttt{0x800001}    &      \texttt{0b00000010}    \\     
  \texttt{P2\_RIGHT} & JAMMA Players Inputs &  \texttt{0x800001}    &     \texttt{0b00000001}    \\     

  \toprule   
  \texttt{SERVICE} & JAMMA Coins &  \texttt{0x800018}       &     \texttt{0b01000000}    \\ 
   \texttt{P2\_START} & JAMMA Coins &  \texttt{0x800018}   &      \texttt{0b00100000}    \\ 
   \texttt{P1\_START} & JAMMA Coins &  \texttt{0x800018}   &      \texttt{0b00010000}    \\   
     \texttt{COIN2\_P2} & JAMMA Coins &  \texttt{0x800018}    &   \texttt{0b00000010}    \\  
   \texttt{COIN\_P1} & JAMMA Coins &  \texttt{0x800018}       &   \texttt{0b00000001}    \\      
     

    \toprule   
    \texttt{DIP1} & JAMMA DIPs &  \texttt{0x80001A}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMA DIPs &  \texttt{0x80001C}    &  \texttt{0bXXXXXXXX}    \\      
    \texttt{DIP2} & JAMMA DIPs &  \texttt{0x80001E}    &  \texttt{0bXXXXXXXX}    \\      
  \toprule   
\end{tabularx}
% \caption*{Input bit layouts}
% \end{figure}  

\subsection{Drawing on screen}
Requesting tiles to be drawn consist in first describing the layout in GFXRAM, then setting the palettes, and finally writing to the CPS-A and CPS-B registers to point them to "where is the data".

\subsubsection{Double buffering}
When a frame is being drawn, neither the data in the GFXRAM nor the CPS-A/CPS-B registers values can be changed. Raster effects are not possible since HSYNC is not forwarded to the m68k. Changes should only occur during the VBLANKing which is signaled via the \icode{VSync} function.

The proper way to avoid visual artifacts is to double buffer the SCROLL/OBJ descriptors in the GFXRAM. While one buffer is used for rasterization until the next VSYNC, the next frame is prepared in the other buffer. On \icode{VSync} the CPS-A and CPS-B registers are written to swap the buffers roles.

\subsubsection{CPS-A and CPS-B registers}
The CPS-A registers are always at the same offset in the m68k memory map and they always use the same layout. 

Depending on the board being targeted, registers of the CPS-B will move and their internal layout will change. A convenient way to deal with this is to use MACROs and have the build system enable the appropriate ones.

Note that all registers are 16-bit wide to accommodate the 68000 operating on them. As shown in the summary table, a register offset is always located on an even address.

\subsubsection{CPS-A Usage}

The CPS-A is controlled via 18 registers.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }  \\     
  \toprule   
  \texttt{OBJ base}  &  \texttt{0x00} & OBJ GFXRAM absolute address   \\   
\texttt{SCROLL1 base} &  \texttt{0x02}  & SCROLL1 GFXRAM absolute address   \\         
\texttt{SCROLL2 base} &  \texttt{0x04}  & SCROLL2 GFXRAM absolute address   \\     
\texttt{SCROLL3 base}&  \texttt{0x06}   & SCROLL3 GFXRAM absolute address  \\     
\texttt{Rowscroll base} &  \texttt{0x08}  & Rowscroll GFXRAM absolute address \\     
\texttt{Palette base} &  \texttt{0x0A}  & Palettes GFXRAM absolute address  \\   
  \toprule   
\texttt{Scroll 1 X} &  \texttt{0x0C}  & SCROLL1 Offset X  \\ 
\texttt{Scroll 1 Y} &  \texttt{0x0E}  & SCROLL1 Offset Y    \\   
\texttt{Scroll 2 X} &  \texttt{0x10}  & SCROLL2 Offset X    \\ 
\texttt{Scroll 2 Y} &  \texttt{0x12}  & SCROLL2 Offset Y    \\   
\texttt{Scroll 3 X} &  \texttt{0x14}  & SCROLL3 Offset X    \\ 
\texttt{Scroll 3 Y} &  \texttt{0x16}  & SCROLL3 Offset Y    \\     
  \toprule   
\texttt{Star1    X} &  \texttt{0x18}  & STAR1   Offset X    \\  
\texttt{Star1    Y} &  \texttt{0x1A}  & STAR1   Offset Y    \\  
\texttt{Star2    X} &  \texttt{0x1C}  & STAR2   Offset X    \\  
\texttt{Star2    Y} &  \texttt{0x1E}  & STAR2   Offset Y    \\  
  \toprule   
\texttt{Rowscroll Offsets} &  \texttt{0x20}  & Offsets into Rowscroll base\\
\texttt{Video Control} &  \texttt{0x22}  & flip screen, rowscroll enable\\
  \toprule   
\end{tabularx}
\caption*{CPS-A registers (offset origin is upper-left in screen space)}
\end{figure}

The base registers tell the CPS-A where it should expected data in GFXRAM. Registers are 16-bit but address must be 24-bit so values are expended \icode{<< 8} upon reception. The linker script should be configured to make sure data structures are aligned properly.

\subsubsection{Row Scrolling}
Rowscrolling allows to offset each visible row on SCROLL2 via a discrete X amounts. In Street Fighter II, Honda's dohyō ( the space in which a sumo wrestling bout occurs) perspective is achieved via linear offset differences. The more perspective needed, the more accentuated is the offset slope. 

\begin{figure}[H]
\nbimg{ring_skew_none.png}
\caption*{Fighters at the center of the dohyō}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_left.png}
\caption*{Fighters move to the left of the dohyō}
 \end{figure}%

\begin{figure}[H]
\nbimg{ring_skew_right.png}
\caption*{Fighters move to the right of the dohyō}
 \end{figure}%

To scroll the whole screen, the CPS-A reads 256 values. That is 224 (each visible lines) + 16 (one tile height above) + 16 (one tile height below) = 256 values to render a frame.

Each unsigned 16-bit offset value is expected in an array located in GFXRAM and pointed to via the CPS-A register \icode{ROWSCROLL\_BASE}.

The \icode{ROWSCROLL\_OFFSET} instructs the CPS-A to use values not starting at \icode{ROWSCROLL\_BASE} but at \icode{ROWSCROLL\_BASE} + \icode{ROWSCROLL\_OFFSET}. 

\begin{figure}[H]
\nbdraw{rowscroll}
 \caption*{CPS-A rowscroll data access}%
 \end{figure}%

% Rowscrolling of SCROLL1 layer is achieved by two registers. Rowscroll base points to an array of 16-bit values. Rowscroll offset is an offset inside the base. How to combine them is elaborated on in the rowscroll section.


A convenient trick is to allocate a rowscroll array of size 1024 with one entry for the full height of \icode{SCROLL2} and generate all the rowscroll offsets. If \icode{SCROLL2} is scrolled vertically, the engine only needs to manipulate \icode{ROWSCROLL\_OFFSET} and no new values are to be generated.

\lstinputlisting[style=CStyle]{src/code/68000/rowscroll.c} 

\subsubsection{Real-life example}

When a contestant in Street Figther II jumps, SCROLL2 moves vertically but no rowscroll offset are re-calculated, only \icode{ROWSCROLL\_OFFSET}  is moved. This allows to amortize the generation of perspective correct rowscroll offset.

Note that rowscroll offsets are unsigned and always indicate an amount to move toward the left side of the screen. To offset toward the right, Street Fighter II developers took advantage of the wrap around nature of the SCROLL layers and used \icode{decalValue = 1024 - desiredRightOffsetValue}.

% \begin{trivia}
% Honda's SCROLL2 features hidden message. It looks like the designers left construction block writings as Upper left, (\begin{CJK}{UTF8}{min}左上\end{CJK}), Upper middle (\begin{CJK}{UTF8}{min}中上\end{CJK}), and Upper right (\begin{CJK}{UTF8}{min}右上\end{CJK}) kanji can be spotted.
% \end{trivia}



\paragraph{Video Control} This register enable/disable misc attributes.

\lstinputlisting[style=CStyle]{src/code/68000/videocontrol.c} 

\label{cpsbreg_programming}
\subsubsection{CPS-B Usage}
The CPS-B features only seven registers but their location change based on the version of the chip.

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{llX}
  \toprule    
  \textbf{Name } & \textbf{ Offset }  & \textbf{Desc }\\  
  \toprule   
  \texttt{Layer control} & \texttt{ 0x26* } & Enable and order layers\\      
\texttt{Priority mask} & \texttt{ 0x28* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2A* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2C* } &  16-bit mask pen values to draw above OBJ   \\  
\texttt{Priority mask} & \texttt{ 0x2E* } &  16-bit mask pen values to draw above OBJ  \\  
\texttt{Palette control} & \texttt{ 0x30* } &  Request palette upload\\ 
  \toprule   
\end{tabularx}
\caption*{CPS-B registers *for Street Fighter 2	(CPS-B 11)}
\end{figure}

\paragraph{Palette control}This register is used to request upload palettes pages, each made of 32 palettes belonging to a same layer.

\lstinputlisting[style=CStyle]{src/code/68000/palettecontrol.c} 

Palette upload does not happen immediately. Instead the CPS-A wait until the next VBLANK and starts reading at the address provided via the PALETTE base register.

The CPS-A does not use a fixed base + offset to lookup a Palette page. If \icode{SCR1} page is not marked for upload, \icode{SCR2} page is expected immediately after \icode{OBJ} palette page.



\paragraph{Layer control} This register allows to enable or disable a layer individually (with the exception of OBJ which disabled by providing an empty list of tiles). It is also used to define the priority of layers \icode{OBJ}, \icode{SCROLL1}, \icode{SCROLL2}, and \icode{SCROLL3} individually.

Note that STARs are always in the back and in order STAR1, STAR2.
  
\lstinputlisting[style=CStyle]{src/code/68000/layercontrol.c} 

The board studied in this book uses a CPS-B 11 which does not support STAR1 and STAR2. These layers were also marginally used in Forgotten Words and Strider. Two good reasons to allow the author to not face its laziness and avoid detailing the STARs bytecode further.



The layer control register is also used to define the order in which OBJ, SCROLL1, SCROLL2, and SCROLL3 should be drawn.

\lstinputlisting[style=CStyle]{src/code/68000/layercontrol2.c} 

\textbf{WARNING :} This bit layout changes across versions of CPS-B. What is presented here is for the CPS-B v11. Refer to Mame for documentation on other versions.

\begin{trivia}
Starfields were used so little that the bytecode mapper was removed altogether from the CPS-2 API while the ASIC retained its circuits.
\end{trivia}



\paragraph{Priority mask}
These four registers control the precedence of pens belonging to the layer behind the OBJ layer. A tile can be assigned to one priority group within a choice of four ranging within\icode{[0-3]}. A group tags pens in the tile palette to be drawn with higher priority via a 16-bit bitfield mask. Marked pens a drawn above OBJs pens.



\lstinputlisting[style=CStyle]{src/code/68000/maskcontrol.c} 

\textbf{TIP :} Tiles using priority group often use a palette where "high priority" colors are grouped together. This makes it easy to tag them in the bitfied because the bits are next to each others. e.g: Mask \icode{0xF000} marks pens \icode{15}, \icode{14}, \icode{13}, and \icode{12} as high priority.




\subsubsection{Drawing OBJs}
To draw sprites and shapes, descriptors must be written to the GFX RAM. Each entry takes four 16-bit WORDS (8 bytes).

\lstinputlisting[style=CStyle]{src/code/68000/sprites.c} 


\lstinputlisting[style=CStyle]{src/code/68000/sprites2.c}  

If the attribute WORD sets the block sizes to zero, a descriptor commands a single tile to be drawn.
 % The immense majority of draw calls in a Capcom games are single tile commands to render a Shape. 
 Otherwise, the command is interpreter as a Sprite rendering command using block size dimensions.

% A shape is made of several single tile draw command resulting in arbitrary forms but a sprite must be rectangular. It is a single draw resulting in multiple tiles rendered but but it does not allow to draw more than the maximum limit of tiles.

The CPS-A will stop reading entries from the OBJ descriptors whether is reaches an empty entry using attribute value \icode{0xFF00} or if 256 tiles are scheduled for rendition.

\textbf{WARNING :} Sprite commands uses only a single entry but every single tiles in them count against the 256 tiles limit. There is no way to cheat, this is an hardware limitation, not an API limitation.


Developers do not have to worry about the \icode{STF29} or GFX partitioning. The tileID is relative to group it belongs to.

\subsubsection{Drawing SCROLLs}

Rendering tilemap is much alike rendering OBJs. Descriptors must be written to the GFX RAM but the layout is much simpler. Each entry is two 16-bit WORDs wide (four bytes).

\lstinputlisting[style=CStyle]{src/code/68000/scrolls.c} 

The attribute WORD is a bit field where we find in particular the palette ID, the group ID which references the priority mask, and the usual X/Y flippers.

\lstinputlisting[style=CStyle]{src/code/68000/scrolls2.c} 

All SCROLLs have different size and tile size but they are all considered Sprites (with rectangular dimensions). They all features 64x64 (4,096) entries. 

 \begin{figure}[H]
\begin{tabularx}{\textwidth}{Xrrr}
  \toprule    
  \textbf{Scroll name } & \textbf{ Tiles Dimensions } & \textbf{ Tile size }  & \textbf{Dimension }\\  
  \toprule   
    
\texttt{SCROLL1} & \texttt{64x64} & \texttt{8x 8 } &  \texttt{512x 512 }  \\  
\texttt{SCROLL2} & \texttt{64x64} & \texttt{16x16 } &  \texttt{1024x1024 }   \\  
\texttt{SCROLL3} & \texttt{64x64} & \texttt{32x32 } &  \texttt{2018x2048 }   \\  
  \toprule   
\end{tabularx}
\vspace*{-1mm} % Ugly hack to make release typeset be like debug. No idea why there is a difference.
\caption*{SCROLLS tile size and dimensions}
\end{figure}

If a full black layer is needed, it can be rendered without using a single tile using either SCROLL or OBJs. Enabling a STAR  layer and providing zeroed bytecode does the trick. It renders a STARfield without any stars in it if the CPS-B supports STARfield.
























\pagebreak

\section{Back in the days}\index{Back in the days!Programming}
The system used by Capcom to program the CP-System remained unknown for many years. Only the nickname of Hiroaki Kondo, a composer/sound programmer often credited as "X68K", rumored a computer manufactured by Sharp. 

In 2018,  Akiman confirmed\cite{x68000usage1}\cite{x68000usage2} that Capcom's SDK, named CAT-1, was launched during the making of Street Fighter II and ran on a Sharp X68000.

\subsection{SHARP X68000}\index{Computers!SHARP X68000}

Unheard of in the rest of the world, the X68000 is a celebrity in Japan where it was nicknamed "god computer". 
Released in 1987, the first machine in the series was as beautiful and powerful as it was expensive (¥369,000, roughly \$3000 in 1987, equivalent to \$7,600 in 2022).

\vfill

 \begin{figure}[H]
\nbimg{68000.png}
\caption*{SHARP's God Computer. Copyright G-Walk\cite{x68k_perfect_catalogue}}
\end{figure}


Despite mind-blowing hardware specifications, SHARP's new product was a risky bet considering it had next to no software at launch. To complicate things further, it used its own text-based OS named Human68k.


\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_front.png}
\end{wrapfigure}

The "Manhattan" twin-tower case of the first model became the signature of the series. 

Notice the vertical bar between the two towers. Pushing it down release a spring to allow the bar to extends past the top of the machine and become a carrying handle.


The most convenient ports for the keyboard, mouse, and joystick are conveniently user facing. An audio jack and a volume control are also present.

The two 5.25 floppy have elegant motorized "soft" ejection systems.

The three LEDs in the upper right indicates the state of the machine. If \icode{POWER} is self-explanatory, \icode{HIGH RESO} indicates whether the video output is using 15KHz, 24KHz, or 31kHz whereas \icode{TIMER} indicates if a self-powering is scheduled. 

In later revisions, \icode{HIGH RESO} was replaced with \icode{HD BUSY} to indicate HDD state.

On the back panel can be found "standard" ports such as additional \icode{Line In} and \icode{Line Out}, and an extra \icode{Joystick \#2} entry.  

\textbf{Images Copyright (left and right): G-Walk\cite{x68k_perfect_catalogue}}.
\pagebreak

\begin{wrapfigure}[35]{l}{0.6\textwidth}
% \vspace{-\baselineskip}
\centering
\simg{0.6}{x68k_back.png}
\end{wrapfigure}



The \icode{TV Control} port allows to drive Sharp monitors and VCRs. It can take advantage of the timer mentioned earlier to schedule a tape recording.

The \icode{See through Color} port is for chroma-keying and rotoscoping.

A \icode{Image In} port for transferring images from a video device, such as a VCR.

A serial port, \icode{RS232C}, as found on many IBM PCs.



The \icode{HDD} and \icode{FDD} ports respectively allow Hard-Drive and Floppy-Drive extensions.

The \icode{100V out} outlet provides power for a monitor.

The \icode{Analog RGB out} port is the equivalent a VGA port to carry the monitor signal.


The \icode{Stereoscopic} port drives “shutter style” 3D glasses.

The \icode{Printer} port is a variant of the commonly called parallel port in USA only it is called Mini-Centronics 36-pin. 

For everything else, the X68000 features two \icode{extension slots} to welcome extension cards.

\textbf{Trivia:} The two \icode{FG} screws are meant for Frame Grounding since Japanese power outlets lack Ground wire and therefore a not grounded.


\pagebreak



\subsection{X68000 Tech specs}  
Inside its gorgeous "Manhattan" case, the machine packed an unparalleled amount of horse power. Even a machine such as the Amiga 500, released the same year and praised in Europe and USA for its prowess, pales in comparison to the X68000. 


 \begin{figure}[H]
\begin{tabularx}{\textwidth}{lXX}
  \toprule    
  \textbf{Type } & \textbf{ X68000 } & \textbf{ Amiga 500 }\\  
  \toprule   
    
CPU & M68000 10MHz & M68000 7.16 MHz\\  
RAM & 1MiB & 512 KiB\\
Max RAM & 4 MiB & 2 MiB\\ 
Colors  & 65,536 colors (stable) & 4,096 (HAM) \\
Resolution & 1024×1024 & 736x483 \\
% Graphics & 1 sprite plane, 2 bg planes, 4 bitmap planes& \\
Sprite engine & 128 units, 16x16 tiles & 8 units, 16x16 tiles\\
% Background engine & 2 in 256x256 \\
VRAM & 1056 KiB & -\\
Sound & Oki MSM6258 (1 channel)  & 4 channels PCM\\ 
Music & Yamaha YM2151 (8 channels)  & -\\ 
Price & \$5,000 & \$1,500 \\
% Storage & Dual 5.25 floppy readers  & \\ 
  \toprule   
\end{tabularx}
\caption*{X68000 vs Amiga 500}
\end{figure}


If both music and sound capabilities were outstanding, it is in the graphics department that the X68000 made jaws hit the floor.

The 1056 KiB of VRAM are divided into three segments feeding four planes. 512 KiB are dedicated to the Text plane, 512 KiB are for the Bitmap plane and the rest, 32 KiB, are for the joined use of the Background plane and Sprite plane. Each plane can be configured to use distinct resolution and layers.

\subsection{Video prowess}

The \textbf{Bitmap Plane} is particularly well suited to plot pixels and render images. Its direct 16bpp color mode was ideal for raytracing application (a M68881 math coprocessor could be added to reduce reduce rendering time). Four modes are available.


\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 512x512 layer with direct 16bpp colors.
\item Two 512x512 layers with shared 8bpp indexed colors.
\item Four 512x512 layers with shared 4bpp indexed colors.
\item One 1024x1024 layer in 4bpp indexed colors.
\end{itemize}

The \textbf{Text Plane} is deceivingly named. It is a bitmap plane which unlike the bitmap plane, expects value across four bitplanes making it well suited to write large quantities of bits with few operations. A m68k writing a 16-bit word can set 16 pixels which makes text rendering very fast when copying characters from a model. Two modes are available.

\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item One 1024x1024 layer with 4bpp indexed colors.
\item Four 512x512 layers with 1bpp monochrome.
\end{itemize}


The \textbf{Background Plane} works as a tilemap. Two modes are available.
\begin{itemize}[topsep=0pt]
% \setlength\itemsep{0.2em}
\item Two 512x512 tilemaps using 8x8 tile with 4bpp indexed colors (16 palettes).
\item One 1024x1024 tilemap using 16x16 tiles with 4bpp indexed colors (16 palettes).
\end{itemize}

The \textbf{Sprite Plane} is a sprite layer allowing 128 sprite on-screen (with a max of 32 sprites per scanlines). Each sprite uses 4bpp indexed color (16 palettes).


 \begin{figure}[H]
\nbdraw{z68k_layers}
\caption*{X68000 planes and layers. Copyright G-Walk\cite{x68k_perfect_catalogue}}
\end{figure}



In total, if all four planes are used in their most complex form, up to eleven layers can compose the screen concurrently. 

An even more impressive feat from the CRT compositor is that all layers of each plane are independently hardware scrollable.

The numerous planes capabilities made the X68000 a versatile instrument able to excel at at wide range of task, from simple text editing to demanding raytracing. 

Video-games were obviously a strength of the machine thanks to its Background and Sprite layers although, as we will see, developers did not employ resources as one would expect.



\subsection{OS}
Developed by Hudson Soft, the operating system named Human68k is strongly inspired by Microsoft's MS-DOS . 

All English name commands such as \icode{DIR}, \icode{COPY} and such are available. In fact, Human68k manual is nearly identical to IBM DOS 4.0J manual\cite{human68k_manual}. The system even uses a \icode{CONFIG.SYS} file to boot.

\begin{figure}[H]
\img{human68k.png}
\caption*{X68000 OS, Human68k}
\end{figure}


Several windows based GUI running on top of Human68k were released over the years. In succession, "VS" (a.k.a) "Visual Shell" in 1987 and later SX-WINDOW (1989).

\begin{figure}[H]
\img{sx-window.png}
\caption*{SX-Window, GUI running on top of Human68k}
\end{figure}



\subsection{A Development machine?}
The similarities between the X68000 and the CPS-1 are many. A quick glance over the specs on page \pageref{x68000-specs} could easily lead to conclude that a small layer of emulation is all a X68000 needed to run CPS-1 games, making it a perfect development machine. 

Since developers never elaborated to which extends SHARP's machine were involved, we can only make an educated guess. A beginning of answer come from the hardware components while Capcom produced software leaves no ambiguities.

\subsubsection{Hardware response}
If the Motorola 680000 CPU and the YM2151 present in both machines are identical, the rest diverge from slightly to significantly.

The sound chip is an OKI but it is "only" a MSM6258. Although it works alike the MSM6296 with ADPCM, it features only one channel which severely impact how rich the sound effects and music systems can be.

The sprite system is, at first sight, weaker than the CPS-1 since the number of tiles displayable is half the capacity (128 instead of 256). But the X68000 access to raster effect allowed multiplexing technique (the Sprite Doubler by Koichi Yoshida\cite{x68000spritedoubler}) bringing the upper limit to 512 sprites!\index{Sprites Multiplexing!X68000}

Lastly, the X68000 floppy storage and its associated slow loading time compared to the CPS-1 ROM. To solve this issue, developers three as much RAM as available, going as far as loading the full content of the floppy at started if the capacity of the X68000 allowed it.



\subsubsection{The 32 KiB VRAM wall}

The real issue, an perhaps the only weakness of the God Computer is the minuscule amount of VRAM dedicated to feed the Sprite and Tilemap layers. Out of 1MiB, only 32KiB is available which results in assets starvation (it can store only  256 16x16 tiles). This limitation knee-capped any potential of using both layers at the same time. A VRAM shared among layers would have been a totally different story.

\subsubsection{Software response}

A definitive answer about the viability of the X68000 as a development station comes from Capcom arcade ports.
\begin{figure}[H]
\label{x68000-specs}
\begin{tabularx}{\textwidth}{lrY}
  \toprule    
  \textbf{Game } & \textbf{Year}  & \textbf{RAM Requirements } \\               
  \toprule   
  Strider & \texttt{1992} &  2 MiB \\
  Final Fight & \texttt{1992} &  2 MiB \\
  Street Fighter 2 Champion Edition & \texttt{1993} &  2 MiB \\
  Super Street Fighter II & \texttt{1994} &  4 MiB \\
  Ghouls'n Ghosts & \texttt{1994} &  2 MiB \\
    \toprule   
\end{tabularx}
\caption*{X68000 Ports of CPS-1 games by Capcom}
\end{figure}

The XM6 Pro-68k emulator and a methodology shared by Upsilandre\cite{x68k_games_analysis} (detailed in the next pages) showed that the GFX rendering architecture of these titles exhibit no pattern of an emulation layer. Each GFX renderer is tailor made to rely heavily on the CPU. 

The stress on the 68000 is confirmed by Ghouls 'n Ghosts manual which recommends a 16MHz CPU and warns about slowdown with a machine using a 10MHz 68000. These leave little doubt in the limited usage of the X68000 to write and test assembly, run TCE, and allocate/compile the GFXROM for CPS-2 games.

\nbimg{gg_manual.jpg}


\subsection{Ports Analysis: Ghouls 'n Ghosts (1994)}
Ghouls 'n Ghosts was released in 1994, six years after the arcade version. It is noteworthy for its low RAM requirements of 2MiB RAM and its resolution of 512x512.
% which is higher than the 384x224 arcade cabinet. 

It is considered a "Perfect port" because of its GFX faithfulness to the CPS-1 version. All the enemies, levels and weapons are there, rendered with the correct rich colors. 

The Tilemaps layer is not used at all since the background lives in two software rendered 512x512 Graphic layers using a shared 8-bit indexed colors palette. The Text layer is also fully software rendered in 1024x1024 16 colors despite the CPU cost of plotting pixels in that mode. The cost and low number of colors makes it a good fit for rendering the GUI elements.

\begin{figure}[H]
\img{x68k_gg_scrw.png}
\caption*{Ghouls 'n Ghosts on SHARP x68000}
\end{figure}


Notice the vertical "cut" in the right of Graphic plane Pages 0 and 1. This artifact reveals the wraparound resulting from hardware scrolling these two layers. This technique allows the CPU to render only new portion of the background. 

The sprites are rendered using the Sprite layer. While rendering the wind blowing in the grass was only about swapping tile ID on CPS-1, the X68000 could not plot that many pixels in the Graphic planes. The solution was to render the blades as sprite overlays.

The rain effect is replicated as seen on page \pageref{gg_rain} via the Text layer start offset. Note there is no DMA to/from the VRAM so every single pixel except for the Sprite layer is plotted by the CPU. Thanks to hardware scrolling, that cost of is amortized.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_gg_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_gg_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak

\subsection{Ports Analysis: Final Fight (1992)}

Final Fight was released in 1992, three years after the arcade version. Alike, Ghouls'n Ghosts port, the game managed to ship on two 5.25-inch 1.2 MiB floppies.

The graphic renders uses the same trade off used by Ghouls 'n Ghosts where usage of the tilemaps is sacrificed in favor of the ability to feed the Sprite layer with tiles. 

Two bitmap layers are used for background elements while the Text layer is used for GUI elements. All these layers are rendered in software with a draw cost amortized thanks to hardware scrolling.

The port of Final Fight to X68000 is close to the arcade version but is not considered "perfect" because of missing graphic elements and color discrepancies. 


\begin{figure}[H]
\img{x68k_ff_scr.png}
\caption*{Final Fight on X68000}
\end{figure}

The number of characters on screen was restricted to 7 which is less than the arcade version where up to 13 where visible. In this case, both the 32 KiB VRAM and the 128 tiles limits were the limiting factor since no multiplexing was possible with free roaming characters.

The Sprite sandwich trick (page \pageref{finalfight_trick}) where parts of the stair case appear in front of the Sprite is done with a special blending mode were the MSBs gives precedence over the Sprite layer. This leaves 7bpp for the color indexes and the Background end up using 128 colors instead of 256. In the other levels, this blending mode is not used so the Bitmap layers go back to using 8bpp for a total of 256 colors available.

The YM2151 let musics be close to the arcade version but without samples. The OKI6295 is dedicated to playing sound effects on its only channel. These audio shortcoming can be countered via support of MIDI audio playback.

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_bitmap2.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_ff_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_ff_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%


\pagebreak
\subsection{Ports Analysis: Street Fighter II Champion Edition (1993)}
Street Fighter II Champion Edition was released only a year after the arcade version.

The volume of assets forced the game to ship on four 5.25-inch 1.2 MiB floppies. The game manages to run with 2 MiB or RAM but suffers numerous loading before when traveling between countries. However, on a machine with 4MiB the game engine loads all floppies to RAM to provide a loading-less experience.

In terms of GFX rendering architecture, the tilemaps are once again ignored to favor the Sprite layer. The floor are software rendered. However the per-line parallax is considerably sped up thanks to the combination of raster effect and hardware scrolling. On each HSYNC events the horizontal hardware offset is adjusted which allows to render Page 0 once for all and never touch it.

Some Sprite elements that used to be rendered on the CPS-1 OBJ layer found their way into the Text layer. This layer is not used for GUI but to render decorative Sprite (  like the statue in Dictator level). It is likely that the 32 KiB was once again not big enough to contain the sprites for both opponents and decorations.

\begin{figure}[H]
\img{x68k_sf2ce_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\pagebreak

The 32 KiB VRAM is updated during VBLANK to be populated with the tiles needed on the next frame. The X68000 RAM is used a Sprite tile Level 1 cache system.

Notice the noise in the Graphic layers, the bottom part in Page 0 and the top part in Page 1. The programmers used every venues willing to stores bytes in order to avoid loading from the floppy drives. The parts of the pages not used for composition are used to "cache" background tiles. When the CPU renders, it transfers VRAM to VRAM (sadly without DMA).

\vspace{-4ex}
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap0.png}
  \caption*{512x512 Graphic Plane Page 0}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%

\pagebreak

Investigating further into Street Fighter 2: Champion Edition confirms the colossal required to convert a CPS-1 title to X68000. The were three problems to solve.

\begin{enumerate}
\item Find where to stores assets.
\item Remain within 32 KiB VRAM per frame.
\item Remain within the m68k software rendering budget
\end{enumerate}

\subsection{Per level renderer}
Whereas, in Final Fight, the background color space was modified on a per-level basis, in Street Fighter II Champion Edition, each arena uses a distinct rendering strategy.

When fighting occurs in China, the Text layer is not used for Sprite decoration like it was in Thailand. Instead it is dedicated to the sky and its animation. Two rows of clouds, accounting for two "frames" animation are drawn once. The hardware offsets are leveraged to parallax the cloud and alternate their shapes. This was likely done because of the fillrate required to update this layer.



\begin{figure}[H]
\img{x68k_sf2ce2_scrw.png}
\caption*{Street Fighter 2 CE on X68000}
\end{figure}


\subsection{Saving further 68000 cycles}
If we look closely at that Page 1 and 2, we see that the background is split. The alley is one Page 2 while the rest is on Page 1 which is surprising since no parallax effect exist (they are on the same plane). 

This reduces overdraw when the Page 1 cyclist crosses the screen and goes over the other cyclist in the back alley which saves a few CPU cycles.

\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
\begin{figure}[H]
\img{x68k_sf2ce2_bitmap0.png}
\caption*{512x512 Graphic Plane Page 0}
\end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
\setlength{\intextsep}{0pt}
  \begin{figure}[H]
  \img{x68k_sf2ce2_bitmap1.png}
  \caption*{512x512 Graphic Plane Page 1}
  \end{figure}
\end{minipage}%

\begin{minipage}[t]{0.49\linewidth}
  \begin{figure}[H]
  \img{x68k_sf2ce2_text.png}
  \caption*{Portion of 1024x1024 Text Layer}
  \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.49\linewidth}
   \begin{figure}[H]
  \img{x68k_sf2ce2_sprites.png}
  \caption*{512x512 Sprite Layer}
  \end{figure}
\end{minipage}%



\subsection{The Rise ...}
 SHARP kept on improving the series with better CPU (68030), more RAM (up to 12MiB) and even bigger HDD (up to 80 MiB). Peripheral manufacturers embraced the computer with extensions cards covering anything users and programmers could desire. 


\begin{figure}[H]
\nbdraw{68000_series}
\caption*{Sharp X68000 series 1987-1993}
\end{figure}






 The risky bet became a phenomenal success. Users loved the platform dearly and publishers released, accounting for games only, no less than 823 titles between 1988 and 1999.


\begin{trivia}
The success was such that a magazine dedicated to the X68000, Oh!X, was published from 1988 to 2000 over 139 volumes. 

\begin{minipage}[t]{0.32\linewidth}
  \img{OhX_1990-04.png}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\linewidth}
 % \begin{figure}[H]
  \img{OhX_1991-02.png}
  % \caption*{Oh!X covers}
% \end{figure}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.322\linewidth}
  \img{OhX_1990-10.png}
\end{minipage}%

Often featuring a raytraced cover to boast the graphic capabilities of the SHARP marvels, each publication came loaded with software, originally on one, then two, and later three 5.25" floppy disks \cite{ohXarticle}!
\end{trivia}

\subsection{... and Fall}
Ultimately, SHARP updates were too timid to keep up. Even its most recent model sporting a Motorola 68030 CPU failed to remain competitive both in terms of prices and performances.

After six years without updating the video or audio pipeline, the 2D oriented design of the machine stated to look dated. Other machines found themselves better fitted to embrace an era of 3D started by companies such as Silicon Graphics, 3DfX, and Verity.

In 1993, many felt a great disturbance in the Force. SHARP had discontinued the "god computer".

